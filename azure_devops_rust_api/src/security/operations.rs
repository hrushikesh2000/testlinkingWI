// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
#![doc = "generated by AutoRust"]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
#![allow(clippy::redundant_clone)]
use super::models;
#[derive(Clone)]
pub struct Client {
    endpoint: String,
    credential: crate::Credential,
    scopes: Vec<String>,
    pipeline: azure_core::Pipeline,
}
#[derive(Clone)]
pub struct ClientBuilder {
    credential: crate::Credential,
    endpoint: Option<String>,
    scopes: Option<Vec<String>>,
}
pub const DEFAULT_ENDPOINT: &str = "https://dev.azure.com";
impl ClientBuilder {
    pub fn new(credential: crate::Credential) -> Self {
        Self {
            credential,
            endpoint: None,
            scopes: None,
        }
    }
    pub fn endpoint(mut self, endpoint: impl Into<String>) -> Self {
        self.endpoint = Some(endpoint.into());
        self
    }
    pub fn scopes(mut self, scopes: &[&str]) -> Self {
        self.scopes = Some(scopes.iter().map(|scope| (*scope).to_owned()).collect());
        self
    }
    pub fn build(self) -> Client {
        let endpoint = self.endpoint.unwrap_or_else(|| DEFAULT_ENDPOINT.to_owned());
        let scopes = self
            .scopes
            .unwrap_or_else(|| vec![format!("{}/", endpoint)]);
        Client::new(endpoint, self.credential, scopes)
    }
}
impl Client {
    pub(crate) fn endpoint(&self) -> &str {
        self.endpoint.as_str()
    }
    pub(crate) fn credential(&self) -> &crate::Credential {
        &self.credential
    }
    pub(crate) async fn send(
        &self,
        request: impl Into<azure_core::Request>,
    ) -> azure_core::error::Result<azure_core::Response> {
        let mut context = azure_core::Context::default();
        let mut request = request.into();
        self.pipeline.send(&mut context, &mut request).await
    }
    pub fn new(
        endpoint: impl Into<String>,
        credential: crate::Credential,
        scopes: Vec<String>,
    ) -> Self {
        let endpoint = endpoint.into();
        let pipeline = azure_core::Pipeline::new(
            option_env!("CARGO_PKG_NAME"),
            option_env!("CARGO_PKG_VERSION"),
            azure_core::ClientOptions::default(),
            Vec::new(),
            Vec::new(),
        );
        Self {
            endpoint,
            credential,
            scopes,
            pipeline,
        }
    }
    pub fn access_control_entries(&self) -> access_control_entries::Client {
        access_control_entries::Client(self.clone())
    }
    pub fn access_control_lists(&self) -> access_control_lists::Client {
        access_control_lists::Client(self.clone())
    }
    pub fn permissions(&self) -> permissions::Client {
        permissions::Client(self.clone())
    }
    pub fn security_namespaces(&self) -> security_namespaces::Client {
        security_namespaces::Client(self.clone())
    }
}
pub mod access_control_entries {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Add or update ACEs in the ACL for the provided token. The request body contains the target token, a list of [ACEs](https://docs.microsoft.com/en-us/rest/api/azure/devops/security/access%20control%20entries/set%20access%20control%20entries?#accesscontrolentry) and a optional merge parameter. In the case of a collision (by identity descriptor) with an existing ACE in the ACL, the \"merge\" parameter determines the behavior. If set, the existing ACE has its allow and deny merged with the incoming ACE's allow and deny. If unset, the existing ACE is displaced."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `security_namespace_id`: Security namespace identifier."]
        #[doc = "* `organization`: The name of the Azure DevOps organization."]
        pub fn set_access_control_entries(
            &self,
            body: impl Into<models::JObject>,
            security_namespace_id: impl Into<String>,
            organization: impl Into<String>,
        ) -> set_access_control_entries::Builder {
            set_access_control_entries::Builder {
                client: self.0.clone(),
                body: body.into(),
                security_namespace_id: security_namespace_id.into(),
                organization: organization.into(),
            }
        }
        #[doc = "Remove the specified ACEs from the ACL belonging to the specified token."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `security_namespace_id`: Security namespace identifier."]
        #[doc = "* `organization`: The name of the Azure DevOps organization."]
        pub fn remove_access_control_entries(
            &self,
            security_namespace_id: impl Into<String>,
            organization: impl Into<String>,
        ) -> remove_access_control_entries::Builder {
            remove_access_control_entries::Builder {
                client: self.0.clone(),
                security_namespace_id: security_namespace_id.into(),
                organization: organization.into(),
                token: None,
                descriptors: None,
            }
        }
    }
    pub mod set_access_control_entries {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::AccessControlEntryList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) body: models::JObject,
            pub(crate) security_namespace_id: String,
            pub(crate) organization: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/_apis/accesscontrolentries/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.security_namespace_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AccessControlEntryList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod remove_access_control_entries {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = bool;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) security_namespace_id: String,
            pub(crate) organization: String,
            pub(crate) token: Option<String>,
            pub(crate) descriptors: Option<String>,
        }
        impl Builder {
            #[doc = "The token whose ACL should be modified."]
            pub fn token(mut self, token: impl Into<String>) -> Self {
                self.token = Some(token.into());
                self
            }
            #[doc = "String containing a list of identity descriptors separated by ',' whose entries should be removed."]
            pub fn descriptors(mut self, descriptors: impl Into<String>) -> Self {
                self.descriptors = Some(descriptors.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/_apis/accesscontrolentries/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.security_namespace_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::DELETE);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(token) = &this.token {
                            url.query_pairs_mut().append_pair("token", token);
                        }
                        if let Some(descriptors) = &this.descriptors {
                            url.query_pairs_mut()
                                .append_pair("descriptors", descriptors);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: bool = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod access_control_lists {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Return a list of access control lists for the specified security namespace and token. All ACLs in the security namespace will be retrieved if no optional parameters are provided."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `security_namespace_id`: Security namespace identifier."]
        #[doc = "* `organization`: The name of the Azure DevOps organization."]
        pub fn query(
            &self,
            security_namespace_id: impl Into<String>,
            organization: impl Into<String>,
        ) -> query::Builder {
            query::Builder {
                client: self.0.clone(),
                security_namespace_id: security_namespace_id.into(),
                organization: organization.into(),
                token: None,
                descriptors: None,
                include_extended_info: None,
                recurse: None,
            }
        }
        #[doc = "Create or update one or more access control lists. All data that currently exists for the ACLs supplied will be overwritten."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `body`: A list of ACLs to create or update."]
        #[doc = "* `security_namespace_id`: Security namespace identifier."]
        #[doc = "* `organization`: The name of the Azure DevOps organization."]
        pub fn set_access_control_lists(
            &self,
            body: impl Into<models::VssJsonCollectionWrapper>,
            security_namespace_id: impl Into<String>,
            organization: impl Into<String>,
        ) -> set_access_control_lists::Builder {
            set_access_control_lists::Builder {
                client: self.0.clone(),
                body: body.into(),
                security_namespace_id: security_namespace_id.into(),
                organization: organization.into(),
            }
        }
        #[doc = "Remove access control lists under the specfied security namespace."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `security_namespace_id`: Security namespace identifier."]
        #[doc = "* `organization`: The name of the Azure DevOps organization."]
        pub fn remove_access_control_lists(
            &self,
            security_namespace_id: impl Into<String>,
            organization: impl Into<String>,
        ) -> remove_access_control_lists::Builder {
            remove_access_control_lists::Builder {
                client: self.0.clone(),
                security_namespace_id: security_namespace_id.into(),
                organization: organization.into(),
                tokens: None,
                recurse: None,
            }
        }
    }
    pub mod query {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::AccessControlListList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) security_namespace_id: String,
            pub(crate) organization: String,
            pub(crate) token: Option<String>,
            pub(crate) descriptors: Option<String>,
            pub(crate) include_extended_info: Option<bool>,
            pub(crate) recurse: Option<bool>,
        }
        impl Builder {
            #[doc = "Security token"]
            pub fn token(mut self, token: impl Into<String>) -> Self {
                self.token = Some(token.into());
                self
            }
            #[doc = "An optional filter string containing a list of identity descriptors separated by ',' whose ACEs should be retrieved. If this is left null, entire ACLs will be returned."]
            pub fn descriptors(mut self, descriptors: impl Into<String>) -> Self {
                self.descriptors = Some(descriptors.into());
                self
            }
            #[doc = "If true, populate the extended information properties for the access control entries contained in the returned lists."]
            pub fn include_extended_info(mut self, include_extended_info: bool) -> Self {
                self.include_extended_info = Some(include_extended_info);
                self
            }
            #[doc = "If true and this is a hierarchical namespace, return child ACLs of the specified token."]
            pub fn recurse(mut self, recurse: bool) -> Self {
                self.recurse = Some(recurse);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/_apis/accesscontrollists/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.security_namespace_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(token) = &this.token {
                            url.query_pairs_mut().append_pair("token", token);
                        }
                        if let Some(descriptors) = &this.descriptors {
                            url.query_pairs_mut()
                                .append_pair("descriptors", descriptors);
                        }
                        if let Some(include_extended_info) = &this.include_extended_info {
                            url.query_pairs_mut().append_pair(
                                "includeExtendedInfo",
                                &include_extended_info.to_string(),
                            );
                        }
                        if let Some(recurse) = &this.recurse {
                            url.query_pairs_mut()
                                .append_pair("recurse", &recurse.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AccessControlListList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod set_access_control_lists {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) body: models::VssJsonCollectionWrapper,
            pub(crate) security_namespace_id: String,
            pub(crate) organization: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/_apis/accesscontrollists/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.security_namespace_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod remove_access_control_lists {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = bool;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) security_namespace_id: String,
            pub(crate) organization: String,
            pub(crate) tokens: Option<String>,
            pub(crate) recurse: Option<bool>,
        }
        impl Builder {
            #[doc = "One or more comma-separated security tokens"]
            pub fn tokens(mut self, tokens: impl Into<String>) -> Self {
                self.tokens = Some(tokens.into());
                self
            }
            #[doc = "If true and this is a hierarchical namespace, also remove child ACLs of the specified tokens."]
            pub fn recurse(mut self, recurse: bool) -> Self {
                self.recurse = Some(recurse);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/_apis/accesscontrollists/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.security_namespace_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::DELETE);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(tokens) = &this.tokens {
                            url.query_pairs_mut().append_pair("tokens", tokens);
                        }
                        if let Some(recurse) = &this.recurse {
                            url.query_pairs_mut()
                                .append_pair("recurse", &recurse.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: bool = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod permissions {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Evaluates whether the caller has the specified permissions on the specified set of security tokens."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `security_namespace_id`: Security namespace identifier."]
        #[doc = "* `organization`: The name of the Azure DevOps organization."]
        #[doc = "* `permissions`: Permissions to evaluate."]
        pub fn has_permissions(
            &self,
            security_namespace_id: impl Into<String>,
            organization: impl Into<String>,
            permissions: i32,
        ) -> has_permissions::Builder {
            has_permissions::Builder {
                client: self.0.clone(),
                security_namespace_id: security_namespace_id.into(),
                organization: organization.into(),
                permissions,
                tokens: None,
                always_allow_administrators: None,
                delimiter: None,
            }
        }
        #[doc = "Removes the specified permissions on a security token for a user or group."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `security_namespace_id`: Security namespace identifier."]
        #[doc = "* `descriptor`: Identity descriptor of the user to remove permissions for."]
        #[doc = "* `organization`: The name of the Azure DevOps organization."]
        #[doc = "* `permissions`: Permissions to remove."]
        pub fn remove_permission(
            &self,
            security_namespace_id: impl Into<String>,
            descriptor: impl Into<String>,
            organization: impl Into<String>,
            permissions: i32,
        ) -> remove_permission::Builder {
            remove_permission::Builder {
                client: self.0.clone(),
                security_namespace_id: security_namespace_id.into(),
                descriptor: descriptor.into(),
                organization: organization.into(),
                permissions,
                token: None,
            }
        }
        #[doc = "Evaluates multiple permissions for the calling user.  Note: This method does not aggregate the results, nor does it short-circuit if one of the permissions evaluates to false."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `body`: The set of evaluation requests."]
        #[doc = "* `organization`: The name of the Azure DevOps organization."]
        pub fn has_permissions_batch(
            &self,
            body: impl Into<models::PermissionEvaluationBatch>,
            organization: impl Into<String>,
        ) -> has_permissions_batch::Builder {
            has_permissions_batch::Builder {
                client: self.0.clone(),
                body: body.into(),
                organization: organization.into(),
            }
        }
    }
    pub mod has_permissions {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = Vec<bool>;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) security_namespace_id: String,
            pub(crate) organization: String,
            pub(crate) permissions: i32,
            pub(crate) tokens: Option<String>,
            pub(crate) always_allow_administrators: Option<bool>,
            pub(crate) delimiter: Option<String>,
        }
        impl Builder {
            #[doc = "One or more security tokens to evaluate."]
            pub fn tokens(mut self, tokens: impl Into<String>) -> Self {
                self.tokens = Some(tokens.into());
                self
            }
            #[doc = "If true and if the caller is an administrator, always return true."]
            pub fn always_allow_administrators(
                mut self,
                always_allow_administrators: bool,
            ) -> Self {
                self.always_allow_administrators = Some(always_allow_administrators);
                self
            }
            #[doc = "Optional security token separator. Defaults to \",\"."]
            pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
                self.delimiter = Some(delimiter.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/_apis/permissions/{}/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.security_namespace_id,
                            &this.permissions
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(tokens) = &this.tokens {
                            url.query_pairs_mut().append_pair("tokens", tokens);
                        }
                        if let Some(always_allow_administrators) = &this.always_allow_administrators
                        {
                            url.query_pairs_mut().append_pair(
                                "alwaysAllowAdministrators",
                                &always_allow_administrators.to_string(),
                            );
                        }
                        if let Some(delimiter) = &this.delimiter {
                            url.query_pairs_mut().append_pair("delimiter", delimiter);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: Vec<bool> = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod remove_permission {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::AccessControlEntry;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) security_namespace_id: String,
            pub(crate) descriptor: String,
            pub(crate) organization: String,
            pub(crate) permissions: i32,
            pub(crate) token: Option<String>,
        }
        impl Builder {
            #[doc = "Security token to remove permissions for."]
            pub fn token(mut self, token: impl Into<String>) -> Self {
                self.token = Some(token.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/_apis/permissions/{}/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.security_namespace_id,
                            &this.permissions
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::DELETE);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let descriptor = &this.descriptor;
                        url.query_pairs_mut().append_pair("descriptor", descriptor);
                        if let Some(token) = &this.token {
                            url.query_pairs_mut().append_pair("token", token);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AccessControlEntry =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod has_permissions_batch {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::PermissionEvaluationBatch;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) body: models::PermissionEvaluationBatch,
            pub(crate) organization: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/_apis/security/permissionevaluationbatch",
                            this.client.endpoint(),
                            &this.organization
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::PermissionEvaluationBatch =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod security_namespaces {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "List all security namespaces or just the specified namespace."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `organization`: The name of the Azure DevOps organization."]
        #[doc = "* `security_namespace_id`: Security namespace identifier."]
        pub fn query(
            &self,
            organization: impl Into<String>,
            security_namespace_id: impl Into<String>,
        ) -> query::Builder {
            query::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                security_namespace_id: security_namespace_id.into(),
                local_only: None,
            }
        }
    }
    pub mod query {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::SecurityNamespaceDescriptionList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) security_namespace_id: String,
            pub(crate) local_only: Option<bool>,
        }
        impl Builder {
            #[doc = "If true, retrieve only local security namespaces."]
            pub fn local_only(mut self, local_only: bool) -> Self {
                self.local_only = Some(local_only);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/_apis/securitynamespaces/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.security_namespace_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(local_only) = &this.local_only {
                            url.query_pairs_mut()
                                .append_pair("localOnly", &local_only.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::SecurityNamespaceDescriptionList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
