// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
#![doc = "generated by AutoRust"]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
#![allow(clippy::redundant_clone)]
use super::models;
#[derive(Clone)]
pub struct Client {
    endpoint: String,
    credential: crate::auth::Credential,
    scopes: Vec<String>,
    pipeline: azure_core::Pipeline,
}
#[derive(Clone)]
pub struct ClientBuilder {
    credential: crate::auth::Credential,
    endpoint: Option<String>,
    scopes: Option<Vec<String>>,
}
pub const DEFAULT_ENDPOINT: &str = "https://vsrm.dev.azure.com";
impl ClientBuilder {
    pub fn new(credential: crate::auth::Credential) -> Self {
        Self {
            credential,
            endpoint: None,
            scopes: None,
        }
    }
    pub fn endpoint(mut self, endpoint: impl Into<String>) -> Self {
        self.endpoint = Some(endpoint.into());
        self
    }
    pub fn scopes(mut self, scopes: &[&str]) -> Self {
        self.scopes = Some(scopes.iter().map(|scope| (*scope).to_owned()).collect());
        self
    }
    pub fn build(self) -> Client {
        let endpoint = self.endpoint.unwrap_or_else(|| DEFAULT_ENDPOINT.to_owned());
        let scopes = self
            .scopes
            .unwrap_or_else(|| vec![format!("{}/", endpoint)]);
        Client::new(endpoint, self.credential, scopes)
    }
}
impl Client {
    pub(crate) fn endpoint(&self) -> &str {
        self.endpoint.as_str()
    }
    pub(crate) fn credential(&self) -> &crate::auth::Credential {
        &self.credential
    }
    pub(crate) async fn send(
        &self,
        request: impl Into<azure_core::Request>,
    ) -> azure_core::error::Result<azure_core::Response> {
        let mut context = azure_core::Context::default();
        let mut request = request.into();
        self.pipeline.send(&mut context, &mut request).await
    }
    pub fn new(
        endpoint: impl Into<String>,
        credential: crate::auth::Credential,
        scopes: Vec<String>,
    ) -> Self {
        let endpoint = endpoint.into();
        let pipeline = azure_core::Pipeline::new(
            option_env!("CARGO_PKG_NAME"),
            option_env!("CARGO_PKG_VERSION"),
            azure_core::ClientOptions::default(),
            Vec::new(),
            Vec::new(),
        );
        Self {
            endpoint,
            credential,
            scopes,
            pipeline,
        }
    }
    pub fn approvals(&self) -> approvals::Client {
        approvals::Client(self.clone())
    }
    pub fn attachments(&self) -> attachments::Client {
        attachments::Client(self.clone())
    }
    pub fn definitions(&self) -> definitions::Client {
        definitions::Client(self.clone())
    }
    pub fn deployments(&self) -> deployments::Client {
        deployments::Client(self.clone())
    }
    pub fn folders(&self) -> folders::Client {
        folders::Client(self.clone())
    }
    pub fn gates(&self) -> gates::Client {
        gates::Client(self.clone())
    }
    pub fn manual_interventions(&self) -> manual_interventions::Client {
        manual_interventions::Client(self.clone())
    }
    pub fn releases(&self) -> releases::Client {
        releases::Client(self.clone())
    }
}
pub mod releases {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get_release(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            release_id: i32,
        ) -> get_release::Builder {
            get_release::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                release_id,
                approval_filters: None,
                property_filters: None,
                expand: None,
                top_gate_records: None,
            }
        }
        pub fn list(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                definition_id: None,
                definition_environment_id: None,
                search_text: None,
                created_by: None,
                status_filter: None,
                environment_status_filter: None,
                min_created_time: None,
                max_created_time: None,
                query_order: None,
                top: None,
                continuation_token: None,
                expand: None,
                artifact_type_id: None,
                source_id: None,
                artifact_version_id: None,
                source_branch_filter: None,
                is_deleted: None,
                tag_filter: None,
                property_filters: None,
                release_id_filter: None,
                path: None,
            }
        }
        pub fn create(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::ReleaseStartMetadata>,
            project: impl Into<String>,
        ) -> create::Builder {
            create::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
            }
        }
        pub fn get_release_revision(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            release_id: i32,
            definition_snapshot_revision: i32,
        ) -> get_release_revision::Builder {
            get_release_revision::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                release_id,
                definition_snapshot_revision,
            }
        }
        pub fn update_release(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::Release>,
            project: impl Into<String>,
            release_id: i32,
        ) -> update_release::Builder {
            update_release::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
                release_id,
            }
        }
        pub fn update_release_resource(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::ReleaseUpdateMetadata>,
            project: impl Into<String>,
            release_id: i32,
        ) -> update_release_resource::Builder {
            update_release_resource::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
                release_id,
            }
        }
        pub fn get_release_environment(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            release_id: i32,
            environment_id: i32,
        ) -> get_release_environment::Builder {
            get_release_environment::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                release_id,
                environment_id,
                expand: None,
            }
        }
        pub fn update_release_environment(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::ReleaseEnvironmentUpdateMetadata>,
            project: impl Into<String>,
            release_id: i32,
            environment_id: i32,
        ) -> update_release_environment::Builder {
            update_release_environment::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
                release_id,
                environment_id,
            }
        }
        pub fn get_task_log(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            release_id: i32,
            environment_id: i32,
            release_deploy_phase_id: i32,
            task_id: i32,
        ) -> get_task_log::Builder {
            get_task_log::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                release_id,
                environment_id,
                release_deploy_phase_id,
                task_id,
                start_line: None,
                end_line: None,
            }
        }
        pub fn get_logs(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            release_id: i32,
        ) -> get_logs::Builder {
            get_logs::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                release_id,
            }
        }
    }
    pub mod get_release {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::Release;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) release_id: i32,
            pub(crate) approval_filters: Option<String>,
            pub(crate) property_filters: Option<String>,
            pub(crate) expand: Option<String>,
            pub(crate) top_gate_records: Option<i32>,
        }
        impl Builder {
            pub fn approval_filters(mut self, approval_filters: impl Into<String>) -> Self {
                self.approval_filters = Some(approval_filters.into());
                self
            }
            pub fn property_filters(mut self, property_filters: impl Into<String>) -> Self {
                self.property_filters = Some(property_filters.into());
                self
            }
            pub fn expand(mut self, expand: impl Into<String>) -> Self {
                self.expand = Some(expand.into());
                self
            }
            pub fn top_gate_records(mut self, top_gate_records: i32) -> Self {
                self.top_gate_records = Some(top_gate_records);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/release/releases/{}?",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.release_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(approval_filters) = &this.approval_filters {
                            url.query_pairs_mut()
                                .append_pair("approvalFilters", approval_filters);
                        }
                        if let Some(property_filters) = &this.property_filters {
                            url.query_pairs_mut()
                                .append_pair("propertyFilters", property_filters);
                        }
                        if let Some(expand) = &this.expand {
                            url.query_pairs_mut().append_pair("$expand", expand);
                        }
                        if let Some(top_gate_records) = &this.top_gate_records {
                            url.query_pairs_mut()
                                .append_pair("$topGateRecords", &top_gate_records.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::Release = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::ReleaseList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) definition_id: Option<i32>,
            pub(crate) definition_environment_id: Option<i32>,
            pub(crate) search_text: Option<String>,
            pub(crate) created_by: Option<String>,
            pub(crate) status_filter: Option<String>,
            pub(crate) environment_status_filter: Option<i32>,
            pub(crate) min_created_time: Option<String>,
            pub(crate) max_created_time: Option<String>,
            pub(crate) query_order: Option<String>,
            pub(crate) top: Option<i32>,
            pub(crate) continuation_token: Option<i32>,
            pub(crate) expand: Option<String>,
            pub(crate) artifact_type_id: Option<String>,
            pub(crate) source_id: Option<String>,
            pub(crate) artifact_version_id: Option<String>,
            pub(crate) source_branch_filter: Option<String>,
            pub(crate) is_deleted: Option<bool>,
            pub(crate) tag_filter: Option<String>,
            pub(crate) property_filters: Option<String>,
            pub(crate) release_id_filter: Option<String>,
            pub(crate) path: Option<String>,
        }
        impl Builder {
            pub fn definition_id(mut self, definition_id: i32) -> Self {
                self.definition_id = Some(definition_id);
                self
            }
            pub fn definition_environment_id(mut self, definition_environment_id: i32) -> Self {
                self.definition_environment_id = Some(definition_environment_id);
                self
            }
            pub fn search_text(mut self, search_text: impl Into<String>) -> Self {
                self.search_text = Some(search_text.into());
                self
            }
            pub fn created_by(mut self, created_by: impl Into<String>) -> Self {
                self.created_by = Some(created_by.into());
                self
            }
            pub fn status_filter(mut self, status_filter: impl Into<String>) -> Self {
                self.status_filter = Some(status_filter.into());
                self
            }
            pub fn environment_status_filter(mut self, environment_status_filter: i32) -> Self {
                self.environment_status_filter = Some(environment_status_filter);
                self
            }
            pub fn min_created_time(mut self, min_created_time: impl Into<String>) -> Self {
                self.min_created_time = Some(min_created_time.into());
                self
            }
            pub fn max_created_time(mut self, max_created_time: impl Into<String>) -> Self {
                self.max_created_time = Some(max_created_time.into());
                self
            }
            pub fn query_order(mut self, query_order: impl Into<String>) -> Self {
                self.query_order = Some(query_order.into());
                self
            }
            pub fn top(mut self, top: i32) -> Self {
                self.top = Some(top);
                self
            }
            pub fn continuation_token(mut self, continuation_token: i32) -> Self {
                self.continuation_token = Some(continuation_token);
                self
            }
            pub fn expand(mut self, expand: impl Into<String>) -> Self {
                self.expand = Some(expand.into());
                self
            }
            pub fn artifact_type_id(mut self, artifact_type_id: impl Into<String>) -> Self {
                self.artifact_type_id = Some(artifact_type_id.into());
                self
            }
            pub fn source_id(mut self, source_id: impl Into<String>) -> Self {
                self.source_id = Some(source_id.into());
                self
            }
            pub fn artifact_version_id(mut self, artifact_version_id: impl Into<String>) -> Self {
                self.artifact_version_id = Some(artifact_version_id.into());
                self
            }
            pub fn source_branch_filter(mut self, source_branch_filter: impl Into<String>) -> Self {
                self.source_branch_filter = Some(source_branch_filter.into());
                self
            }
            pub fn is_deleted(mut self, is_deleted: bool) -> Self {
                self.is_deleted = Some(is_deleted);
                self
            }
            pub fn tag_filter(mut self, tag_filter: impl Into<String>) -> Self {
                self.tag_filter = Some(tag_filter.into());
                self
            }
            pub fn property_filters(mut self, property_filters: impl Into<String>) -> Self {
                self.property_filters = Some(property_filters.into());
                self
            }
            pub fn release_id_filter(mut self, release_id_filter: impl Into<String>) -> Self {
                self.release_id_filter = Some(release_id_filter.into());
                self
            }
            pub fn path(mut self, path: impl Into<String>) -> Self {
                self.path = Some(path.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/release/releases",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(definition_id) = &this.definition_id {
                            url.query_pairs_mut()
                                .append_pair("definitionId", &definition_id.to_string());
                        }
                        if let Some(definition_environment_id) = &this.definition_environment_id {
                            url.query_pairs_mut().append_pair(
                                "definitionEnvironmentId",
                                &definition_environment_id.to_string(),
                            );
                        }
                        if let Some(search_text) = &this.search_text {
                            url.query_pairs_mut().append_pair("searchText", search_text);
                        }
                        if let Some(created_by) = &this.created_by {
                            url.query_pairs_mut().append_pair("createdBy", created_by);
                        }
                        if let Some(status_filter) = &this.status_filter {
                            url.query_pairs_mut()
                                .append_pair("statusFilter", status_filter);
                        }
                        if let Some(environment_status_filter) = &this.environment_status_filter {
                            url.query_pairs_mut().append_pair(
                                "environmentStatusFilter",
                                &environment_status_filter.to_string(),
                            );
                        }
                        if let Some(min_created_time) = &this.min_created_time {
                            url.query_pairs_mut()
                                .append_pair("minCreatedTime", min_created_time);
                        }
                        if let Some(max_created_time) = &this.max_created_time {
                            url.query_pairs_mut()
                                .append_pair("maxCreatedTime", max_created_time);
                        }
                        if let Some(query_order) = &this.query_order {
                            url.query_pairs_mut().append_pair("queryOrder", query_order);
                        }
                        if let Some(top) = &this.top {
                            url.query_pairs_mut().append_pair("$top", &top.to_string());
                        }
                        if let Some(continuation_token) = &this.continuation_token {
                            url.query_pairs_mut()
                                .append_pair("continuationToken", &continuation_token.to_string());
                        }
                        if let Some(expand) = &this.expand {
                            url.query_pairs_mut().append_pair("$expand", expand);
                        }
                        if let Some(artifact_type_id) = &this.artifact_type_id {
                            url.query_pairs_mut()
                                .append_pair("artifactTypeId", artifact_type_id);
                        }
                        if let Some(source_id) = &this.source_id {
                            url.query_pairs_mut().append_pair("sourceId", source_id);
                        }
                        if let Some(artifact_version_id) = &this.artifact_version_id {
                            url.query_pairs_mut()
                                .append_pair("artifactVersionId", artifact_version_id);
                        }
                        if let Some(source_branch_filter) = &this.source_branch_filter {
                            url.query_pairs_mut()
                                .append_pair("sourceBranchFilter", source_branch_filter);
                        }
                        if let Some(is_deleted) = &this.is_deleted {
                            url.query_pairs_mut()
                                .append_pair("isDeleted", &is_deleted.to_string());
                        }
                        if let Some(tag_filter) = &this.tag_filter {
                            url.query_pairs_mut().append_pair("tagFilter", tag_filter);
                        }
                        if let Some(property_filters) = &this.property_filters {
                            url.query_pairs_mut()
                                .append_pair("propertyFilters", property_filters);
                        }
                        if let Some(release_id_filter) = &this.release_id_filter {
                            url.query_pairs_mut()
                                .append_pair("releaseIdFilter", release_id_filter);
                        }
                        if let Some(path) = &this.path {
                            url.query_pairs_mut().append_pair("path", path);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ReleaseList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod create {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::Release;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::ReleaseStartMetadata,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/release/releases",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::Release = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_release_revision {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = String;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) release_id: i32,
            pub(crate) definition_snapshot_revision: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/release/releases/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.release_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let definition_snapshot_revision = &this.definition_snapshot_revision;
                        url.query_pairs_mut().append_pair(
                            "definitionSnapshotRevision",
                            &definition_snapshot_revision.to_string(),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: String = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod update_release {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::Release;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::Release,
            pub(crate) project: String,
            pub(crate) release_id: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/release/releases/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.release_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::PUT);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::Release = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod update_release_resource {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::Release;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::ReleaseUpdateMetadata,
            pub(crate) project: String,
            pub(crate) release_id: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/release/releases/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.release_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::PATCH);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::Release = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_release_environment {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::ReleaseEnvironment;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) release_id: i32,
            pub(crate) environment_id: i32,
            pub(crate) expand: Option<String>,
        }
        impl Builder {
            pub fn expand(mut self, expand: impl Into<String>) -> Self {
                self.expand = Some(expand.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/Release/releases/{}/environments/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.release_id,
                            &this.environment_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(expand) = &this.expand {
                            url.query_pairs_mut().append_pair("$expand", expand);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ReleaseEnvironment =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod update_release_environment {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::ReleaseEnvironment;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::ReleaseEnvironmentUpdateMetadata,
            pub(crate) project: String,
            pub(crate) release_id: i32,
            pub(crate) environment_id: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/Release/releases/{}/environments/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.release_id,
                            &this.environment_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::PATCH);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ReleaseEnvironment =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_task_log {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = String;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) release_id: i32,
            pub(crate) environment_id: i32,
            pub(crate) release_deploy_phase_id: i32,
            pub(crate) task_id: i32,
            pub(crate) start_line: Option<i64>,
            pub(crate) end_line: Option<i64>,
        }
        impl Builder {
            pub fn start_line(mut self, start_line: i64) -> Self {
                self.start_line = Some(start_line);
                self
            }
            pub fn end_line(mut self, end_line: i64) -> Self {
                self.end_line = Some(end_line);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = & format ! ("{}/{}/{}/_apis/release/releases/{}/environments/{}/deployPhases/{}/tasks/{}/logs" , this . client . endpoint () , & this . organization , & this . project , & this . release_id , & this . environment_id , & this . release_deploy_phase_id , & this . task_id) ;
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(start_line) = &this.start_line {
                            url.query_pairs_mut()
                                .append_pair("startLine", &start_line.to_string());
                        }
                        if let Some(end_line) = &this.end_line {
                            url.query_pairs_mut()
                                .append_pair("endLine", &end_line.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: String = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_logs {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = String;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) release_id: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/release/releases/{}/logs",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.release_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: String = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod approvals {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                assigned_to_filter: None,
                status_filter: None,
                release_ids_filter: None,
                type_filter: None,
                top: None,
                continuation_token: None,
                query_order: None,
                include_my_group_approvals: None,
            }
        }
        pub fn update(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::ReleaseApproval>,
            project: impl Into<String>,
            approval_id: i32,
        ) -> update::Builder {
            update::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
                approval_id,
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::ReleaseApprovalList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) assigned_to_filter: Option<String>,
            pub(crate) status_filter: Option<String>,
            pub(crate) release_ids_filter: Option<String>,
            pub(crate) type_filter: Option<String>,
            pub(crate) top: Option<i32>,
            pub(crate) continuation_token: Option<i32>,
            pub(crate) query_order: Option<String>,
            pub(crate) include_my_group_approvals: Option<bool>,
        }
        impl Builder {
            pub fn assigned_to_filter(mut self, assigned_to_filter: impl Into<String>) -> Self {
                self.assigned_to_filter = Some(assigned_to_filter.into());
                self
            }
            pub fn status_filter(mut self, status_filter: impl Into<String>) -> Self {
                self.status_filter = Some(status_filter.into());
                self
            }
            pub fn release_ids_filter(mut self, release_ids_filter: impl Into<String>) -> Self {
                self.release_ids_filter = Some(release_ids_filter.into());
                self
            }
            pub fn type_filter(mut self, type_filter: impl Into<String>) -> Self {
                self.type_filter = Some(type_filter.into());
                self
            }
            pub fn top(mut self, top: i32) -> Self {
                self.top = Some(top);
                self
            }
            pub fn continuation_token(mut self, continuation_token: i32) -> Self {
                self.continuation_token = Some(continuation_token);
                self
            }
            pub fn query_order(mut self, query_order: impl Into<String>) -> Self {
                self.query_order = Some(query_order.into());
                self
            }
            pub fn include_my_group_approvals(mut self, include_my_group_approvals: bool) -> Self {
                self.include_my_group_approvals = Some(include_my_group_approvals);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/release/approvals",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(assigned_to_filter) = &this.assigned_to_filter {
                            url.query_pairs_mut()
                                .append_pair("assignedToFilter", assigned_to_filter);
                        }
                        if let Some(status_filter) = &this.status_filter {
                            url.query_pairs_mut()
                                .append_pair("statusFilter", status_filter);
                        }
                        if let Some(release_ids_filter) = &this.release_ids_filter {
                            url.query_pairs_mut()
                                .append_pair("releaseIdsFilter", release_ids_filter);
                        }
                        if let Some(type_filter) = &this.type_filter {
                            url.query_pairs_mut().append_pair("typeFilter", type_filter);
                        }
                        if let Some(top) = &this.top {
                            url.query_pairs_mut().append_pair("top", &top.to_string());
                        }
                        if let Some(continuation_token) = &this.continuation_token {
                            url.query_pairs_mut()
                                .append_pair("continuationToken", &continuation_token.to_string());
                        }
                        if let Some(query_order) = &this.query_order {
                            url.query_pairs_mut().append_pair("queryOrder", query_order);
                        }
                        if let Some(include_my_group_approvals) = &this.include_my_group_approvals {
                            url.query_pairs_mut().append_pair(
                                "includeMyGroupApprovals",
                                &include_my_group_approvals.to_string(),
                            );
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ReleaseApprovalList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod update {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::ReleaseApproval;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::ReleaseApproval,
            pub(crate) project: String,
            pub(crate) approval_id: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/release/approvals/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.approval_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::PATCH);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ReleaseApproval =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod definitions {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                search_text: None,
                expand: None,
                artifact_type: None,
                artifact_source_id: None,
                top: None,
                continuation_token: None,
                query_order: None,
                path: None,
                is_exact_name_match: None,
                tag_filter: None,
                property_filters: None,
                definition_id_filter: None,
                is_deleted: None,
                search_text_contains_folder_name: None,
            }
        }
        pub fn create(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::ReleaseDefinition>,
            project: impl Into<String>,
        ) -> create::Builder {
            create::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
            }
        }
        pub fn update(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::ReleaseDefinition>,
            project: impl Into<String>,
        ) -> update::Builder {
            update::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
            }
        }
        pub fn get(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            definition_id: i32,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                definition_id,
                property_filters: None,
            }
        }
        pub fn delete(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            definition_id: i32,
        ) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                definition_id,
                comment: None,
                force_delete: None,
            }
        }
        pub fn get_release_definition_history(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            definition_id: i32,
        ) -> get_release_definition_history::Builder {
            get_release_definition_history::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                definition_id,
            }
        }
        pub fn get_definition_revision(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            definition_id: i32,
            revision: i32,
        ) -> get_definition_revision::Builder {
            get_definition_revision::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                definition_id,
                revision,
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::ReleaseDefinitionList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) search_text: Option<String>,
            pub(crate) expand: Option<String>,
            pub(crate) artifact_type: Option<String>,
            pub(crate) artifact_source_id: Option<String>,
            pub(crate) top: Option<i32>,
            pub(crate) continuation_token: Option<String>,
            pub(crate) query_order: Option<String>,
            pub(crate) path: Option<String>,
            pub(crate) is_exact_name_match: Option<bool>,
            pub(crate) tag_filter: Option<String>,
            pub(crate) property_filters: Option<String>,
            pub(crate) definition_id_filter: Option<String>,
            pub(crate) is_deleted: Option<bool>,
            pub(crate) search_text_contains_folder_name: Option<bool>,
        }
        impl Builder {
            pub fn search_text(mut self, search_text: impl Into<String>) -> Self {
                self.search_text = Some(search_text.into());
                self
            }
            pub fn expand(mut self, expand: impl Into<String>) -> Self {
                self.expand = Some(expand.into());
                self
            }
            pub fn artifact_type(mut self, artifact_type: impl Into<String>) -> Self {
                self.artifact_type = Some(artifact_type.into());
                self
            }
            pub fn artifact_source_id(mut self, artifact_source_id: impl Into<String>) -> Self {
                self.artifact_source_id = Some(artifact_source_id.into());
                self
            }
            pub fn top(mut self, top: i32) -> Self {
                self.top = Some(top);
                self
            }
            pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
                self.continuation_token = Some(continuation_token.into());
                self
            }
            pub fn query_order(mut self, query_order: impl Into<String>) -> Self {
                self.query_order = Some(query_order.into());
                self
            }
            pub fn path(mut self, path: impl Into<String>) -> Self {
                self.path = Some(path.into());
                self
            }
            pub fn is_exact_name_match(mut self, is_exact_name_match: bool) -> Self {
                self.is_exact_name_match = Some(is_exact_name_match);
                self
            }
            pub fn tag_filter(mut self, tag_filter: impl Into<String>) -> Self {
                self.tag_filter = Some(tag_filter.into());
                self
            }
            pub fn property_filters(mut self, property_filters: impl Into<String>) -> Self {
                self.property_filters = Some(property_filters.into());
                self
            }
            pub fn definition_id_filter(mut self, definition_id_filter: impl Into<String>) -> Self {
                self.definition_id_filter = Some(definition_id_filter.into());
                self
            }
            pub fn is_deleted(mut self, is_deleted: bool) -> Self {
                self.is_deleted = Some(is_deleted);
                self
            }
            pub fn search_text_contains_folder_name(
                mut self,
                search_text_contains_folder_name: bool,
            ) -> Self {
                self.search_text_contains_folder_name = Some(search_text_contains_folder_name);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/release/definitions",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(search_text) = &this.search_text {
                            url.query_pairs_mut().append_pair("searchText", search_text);
                        }
                        if let Some(expand) = &this.expand {
                            url.query_pairs_mut().append_pair("$expand", expand);
                        }
                        if let Some(artifact_type) = &this.artifact_type {
                            url.query_pairs_mut()
                                .append_pair("artifactType", artifact_type);
                        }
                        if let Some(artifact_source_id) = &this.artifact_source_id {
                            url.query_pairs_mut()
                                .append_pair("artifactSourceId", artifact_source_id);
                        }
                        if let Some(top) = &this.top {
                            url.query_pairs_mut().append_pair("$top", &top.to_string());
                        }
                        if let Some(continuation_token) = &this.continuation_token {
                            url.query_pairs_mut()
                                .append_pair("continuationToken", continuation_token);
                        }
                        if let Some(query_order) = &this.query_order {
                            url.query_pairs_mut().append_pair("queryOrder", query_order);
                        }
                        if let Some(path) = &this.path {
                            url.query_pairs_mut().append_pair("path", path);
                        }
                        if let Some(is_exact_name_match) = &this.is_exact_name_match {
                            url.query_pairs_mut()
                                .append_pair("isExactNameMatch", &is_exact_name_match.to_string());
                        }
                        if let Some(tag_filter) = &this.tag_filter {
                            url.query_pairs_mut().append_pair("tagFilter", tag_filter);
                        }
                        if let Some(property_filters) = &this.property_filters {
                            url.query_pairs_mut()
                                .append_pair("propertyFilters", property_filters);
                        }
                        if let Some(definition_id_filter) = &this.definition_id_filter {
                            url.query_pairs_mut()
                                .append_pair("definitionIdFilter", definition_id_filter);
                        }
                        if let Some(is_deleted) = &this.is_deleted {
                            url.query_pairs_mut()
                                .append_pair("isDeleted", &is_deleted.to_string());
                        }
                        if let Some(search_text_contains_folder_name) =
                            &this.search_text_contains_folder_name
                        {
                            url.query_pairs_mut().append_pair(
                                "searchTextContainsFolderName",
                                &search_text_contains_folder_name.to_string(),
                            );
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ReleaseDefinitionList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod create {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::ReleaseDefinition;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::ReleaseDefinition,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/release/definitions",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ReleaseDefinition =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod update {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::ReleaseDefinition;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::ReleaseDefinition,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/release/definitions",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::PUT);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ReleaseDefinition =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::ReleaseDefinition;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) definition_id: i32,
            pub(crate) property_filters: Option<String>,
        }
        impl Builder {
            pub fn property_filters(mut self, property_filters: impl Into<String>) -> Self {
                self.property_filters = Some(property_filters.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/release/definitions/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.definition_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(property_filters) = &this.property_filters {
                            url.query_pairs_mut()
                                .append_pair("propertyFilters", property_filters);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ReleaseDefinition =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) definition_id: i32,
            pub(crate) comment: Option<String>,
            pub(crate) force_delete: Option<bool>,
        }
        impl Builder {
            pub fn comment(mut self, comment: impl Into<String>) -> Self {
                self.comment = Some(comment.into());
                self
            }
            pub fn force_delete(mut self, force_delete: bool) -> Self {
                self.force_delete = Some(force_delete);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/release/definitions/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.definition_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::DELETE);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(comment) = &this.comment {
                            url.query_pairs_mut().append_pair("comment", comment);
                        }
                        if let Some(force_delete) = &this.force_delete {
                            url.query_pairs_mut()
                                .append_pair("forceDelete", &force_delete.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_release_definition_history {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::ReleaseDefinitionRevisionList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) definition_id: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/Release/definitions/{}/revisions",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.definition_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ReleaseDefinitionRevisionList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_definition_revision {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = String;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) definition_id: i32,
            pub(crate) revision: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/Release/definitions/{}/revisions/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.definition_id,
                            &this.revision
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: String = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod deployments {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                definition_id: None,
                definition_environment_id: None,
                created_by: None,
                min_modified_time: None,
                max_modified_time: None,
                deployment_status: None,
                operation_status: None,
                latest_attempts_only: None,
                query_order: None,
                top: None,
                continuation_token: None,
                created_for: None,
                min_started_time: None,
                max_started_time: None,
                source_branch: None,
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::DeploymentList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) definition_id: Option<i32>,
            pub(crate) definition_environment_id: Option<i32>,
            pub(crate) created_by: Option<String>,
            pub(crate) min_modified_time: Option<String>,
            pub(crate) max_modified_time: Option<String>,
            pub(crate) deployment_status: Option<String>,
            pub(crate) operation_status: Option<String>,
            pub(crate) latest_attempts_only: Option<bool>,
            pub(crate) query_order: Option<String>,
            pub(crate) top: Option<i32>,
            pub(crate) continuation_token: Option<i32>,
            pub(crate) created_for: Option<String>,
            pub(crate) min_started_time: Option<String>,
            pub(crate) max_started_time: Option<String>,
            pub(crate) source_branch: Option<String>,
        }
        impl Builder {
            pub fn definition_id(mut self, definition_id: i32) -> Self {
                self.definition_id = Some(definition_id);
                self
            }
            pub fn definition_environment_id(mut self, definition_environment_id: i32) -> Self {
                self.definition_environment_id = Some(definition_environment_id);
                self
            }
            pub fn created_by(mut self, created_by: impl Into<String>) -> Self {
                self.created_by = Some(created_by.into());
                self
            }
            pub fn min_modified_time(mut self, min_modified_time: impl Into<String>) -> Self {
                self.min_modified_time = Some(min_modified_time.into());
                self
            }
            pub fn max_modified_time(mut self, max_modified_time: impl Into<String>) -> Self {
                self.max_modified_time = Some(max_modified_time.into());
                self
            }
            pub fn deployment_status(mut self, deployment_status: impl Into<String>) -> Self {
                self.deployment_status = Some(deployment_status.into());
                self
            }
            pub fn operation_status(mut self, operation_status: impl Into<String>) -> Self {
                self.operation_status = Some(operation_status.into());
                self
            }
            pub fn latest_attempts_only(mut self, latest_attempts_only: bool) -> Self {
                self.latest_attempts_only = Some(latest_attempts_only);
                self
            }
            pub fn query_order(mut self, query_order: impl Into<String>) -> Self {
                self.query_order = Some(query_order.into());
                self
            }
            pub fn top(mut self, top: i32) -> Self {
                self.top = Some(top);
                self
            }
            pub fn continuation_token(mut self, continuation_token: i32) -> Self {
                self.continuation_token = Some(continuation_token);
                self
            }
            pub fn created_for(mut self, created_for: impl Into<String>) -> Self {
                self.created_for = Some(created_for.into());
                self
            }
            pub fn min_started_time(mut self, min_started_time: impl Into<String>) -> Self {
                self.min_started_time = Some(min_started_time.into());
                self
            }
            pub fn max_started_time(mut self, max_started_time: impl Into<String>) -> Self {
                self.max_started_time = Some(max_started_time.into());
                self
            }
            pub fn source_branch(mut self, source_branch: impl Into<String>) -> Self {
                self.source_branch = Some(source_branch.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/release/deployments",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(definition_id) = &this.definition_id {
                            url.query_pairs_mut()
                                .append_pair("definitionId", &definition_id.to_string());
                        }
                        if let Some(definition_environment_id) = &this.definition_environment_id {
                            url.query_pairs_mut().append_pair(
                                "definitionEnvironmentId",
                                &definition_environment_id.to_string(),
                            );
                        }
                        if let Some(created_by) = &this.created_by {
                            url.query_pairs_mut().append_pair("createdBy", created_by);
                        }
                        if let Some(min_modified_time) = &this.min_modified_time {
                            url.query_pairs_mut()
                                .append_pair("minModifiedTime", min_modified_time);
                        }
                        if let Some(max_modified_time) = &this.max_modified_time {
                            url.query_pairs_mut()
                                .append_pair("maxModifiedTime", max_modified_time);
                        }
                        if let Some(deployment_status) = &this.deployment_status {
                            url.query_pairs_mut()
                                .append_pair("deploymentStatus", deployment_status);
                        }
                        if let Some(operation_status) = &this.operation_status {
                            url.query_pairs_mut()
                                .append_pair("operationStatus", operation_status);
                        }
                        if let Some(latest_attempts_only) = &this.latest_attempts_only {
                            url.query_pairs_mut().append_pair(
                                "latestAttemptsOnly",
                                &latest_attempts_only.to_string(),
                            );
                        }
                        if let Some(query_order) = &this.query_order {
                            url.query_pairs_mut().append_pair("queryOrder", query_order);
                        }
                        if let Some(top) = &this.top {
                            url.query_pairs_mut().append_pair("$top", &top.to_string());
                        }
                        if let Some(continuation_token) = &this.continuation_token {
                            url.query_pairs_mut()
                                .append_pair("continuationToken", &continuation_token.to_string());
                        }
                        if let Some(created_for) = &this.created_for {
                            url.query_pairs_mut().append_pair("createdFor", created_for);
                        }
                        if let Some(min_started_time) = &this.min_started_time {
                            url.query_pairs_mut()
                                .append_pair("minStartedTime", min_started_time);
                        }
                        if let Some(max_started_time) = &this.max_started_time {
                            url.query_pairs_mut()
                                .append_pair("maxStartedTime", max_started_time);
                        }
                        if let Some(source_branch) = &this.source_branch {
                            url.query_pairs_mut()
                                .append_pair("sourceBranch", source_branch);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::DeploymentList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod folders {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            path: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                path: path.into(),
                query_order: None,
            }
        }
        pub fn create(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::Folder>,
            project: impl Into<String>,
            path: impl Into<String>,
        ) -> create::Builder {
            create::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
                path: path.into(),
            }
        }
        pub fn update(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::Folder>,
            project: impl Into<String>,
            path: impl Into<String>,
        ) -> update::Builder {
            update::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
                path: path.into(),
            }
        }
        pub fn delete(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            path: impl Into<String>,
        ) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                path: path.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::FolderList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) path: String,
            pub(crate) query_order: Option<String>,
        }
        impl Builder {
            pub fn query_order(mut self, query_order: impl Into<String>) -> Self {
                self.query_order = Some(query_order.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/release/folders/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.path
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        if let Some(query_order) = &this.query_order {
                            url.query_pairs_mut().append_pair("queryOrder", query_order);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::FolderList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod create {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::Folder;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::Folder,
            pub(crate) project: String,
            pub(crate) path: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/release/folders/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.path
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::POST);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::Folder = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod update {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::Folder;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::Folder,
            pub(crate) project: String,
            pub(crate) path: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/release/folders/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.path
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::PATCH);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::Folder = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) path: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/release/folders/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.path
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::DELETE);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod gates {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn update(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GateUpdateMetadata>,
            project: impl Into<String>,
            gate_step_id: i32,
        ) -> update::Builder {
            update::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
                gate_step_id,
            }
        }
    }
    pub mod update {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::ReleaseGates;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GateUpdateMetadata,
            pub(crate) project: String,
            pub(crate) gate_step_id: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/release/gates/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.gate_step_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::PATCH);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ReleaseGates =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod attachments {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get_release_task_attachments(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            release_id: i32,
            environment_id: i32,
            attempt_id: i32,
            plan_id: impl Into<String>,
            type_: impl Into<String>,
        ) -> get_release_task_attachments::Builder {
            get_release_task_attachments::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                release_id,
                environment_id,
                attempt_id,
                plan_id: plan_id.into(),
                type_: type_.into(),
            }
        }
        pub fn get_release_task_attachment_content(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            release_id: i32,
            environment_id: i32,
            attempt_id: i32,
            plan_id: impl Into<String>,
            timeline_id: impl Into<String>,
            record_id: impl Into<String>,
            type_: impl Into<String>,
            name: impl Into<String>,
        ) -> get_release_task_attachment_content::Builder {
            get_release_task_attachment_content::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                release_id,
                environment_id,
                attempt_id,
                plan_id: plan_id.into(),
                timeline_id: timeline_id.into(),
                record_id: record_id.into(),
                type_: type_.into(),
                name: name.into(),
            }
        }
        pub fn get_task_attachments(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            release_id: i32,
            environment_id: i32,
            attempt_id: i32,
            timeline_id: impl Into<String>,
            type_: impl Into<String>,
        ) -> get_task_attachments::Builder {
            get_task_attachments::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                release_id,
                environment_id,
                attempt_id,
                timeline_id: timeline_id.into(),
                type_: type_.into(),
            }
        }
        pub fn get_task_attachment_content(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            release_id: i32,
            environment_id: i32,
            attempt_id: i32,
            timeline_id: impl Into<String>,
            record_id: impl Into<String>,
            type_: impl Into<String>,
            name: impl Into<String>,
        ) -> get_task_attachment_content::Builder {
            get_task_attachment_content::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                release_id,
                environment_id,
                attempt_id,
                timeline_id: timeline_id.into(),
                record_id: record_id.into(),
                type_: type_.into(),
                name: name.into(),
            }
        }
    }
    pub mod get_release_task_attachments {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::ReleaseTaskAttachmentList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) release_id: i32,
            pub(crate) environment_id: i32,
            pub(crate) attempt_id: i32,
            pub(crate) plan_id: String,
            pub(crate) type_: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = & format ! ("{}/{}/{}/_apis/release/releases/{}/environments/{}/attempts/{}/plan/{}/attachments/{}" , this . client . endpoint () , & this . organization , & this . project , & this . release_id , & this . environment_id , & this . attempt_id , & this . plan_id , & this . type_) ;
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ReleaseTaskAttachmentList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_release_task_attachment_content {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = String;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) release_id: i32,
            pub(crate) environment_id: i32,
            pub(crate) attempt_id: i32,
            pub(crate) plan_id: String,
            pub(crate) timeline_id: String,
            pub(crate) record_id: String,
            pub(crate) type_: String,
            pub(crate) name: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = & format ! ("{}/{}/{}/_apis/release/releases/{}/environments/{}/attempts/{}/plan/{}/timelines/{}/records/{}/attachments/{}/{}" , this . client . endpoint () , & this . organization , & this . project , & this . release_id , & this . environment_id , & this . attempt_id , & this . plan_id , & this . timeline_id , & this . record_id , & this . type_ , & this . name) ;
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: String = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_task_attachments {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::ReleaseTaskAttachmentList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) release_id: i32,
            pub(crate) environment_id: i32,
            pub(crate) attempt_id: i32,
            pub(crate) timeline_id: String,
            pub(crate) type_: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = & format ! ("{}/{}/{}/_apis/release/releases/{}/environments/{}/attempts/{}/timelines/{}/attachments/{}" , this . client . endpoint () , & this . organization , & this . project , & this . release_id , & this . environment_id , & this . attempt_id , & this . timeline_id , & this . type_) ;
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ReleaseTaskAttachmentList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get_task_attachment_content {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = String;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) release_id: i32,
            pub(crate) environment_id: i32,
            pub(crate) attempt_id: i32,
            pub(crate) timeline_id: String,
            pub(crate) record_id: String,
            pub(crate) type_: String,
            pub(crate) name: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = & format ! ("{}/{}/{}/_apis/release/releases/{}/environments/{}/attempts/{}/timelines/{}/records/{}/attachments/{}/{}" , this . client . endpoint () , & this . organization , & this . project , & this . release_id , & this . environment_id , & this . attempt_id , & this . timeline_id , & this . record_id , & this . type_ , & this . name) ;
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: String = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
pub mod manual_interventions {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            release_id: i32,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                release_id,
            }
        }
        pub fn get(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            release_id: i32,
            manual_intervention_id: i32,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                release_id,
                manual_intervention_id,
            }
        }
        pub fn update(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::ManualInterventionUpdateMetadata>,
            project: impl Into<String>,
            release_id: i32,
            manual_intervention_id: i32,
        ) -> update::Builder {
            update::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
                release_id,
                manual_intervention_id,
            }
        }
    }
    pub mod list {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::ManualInterventionList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) release_id: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/Release/releases/{}/manualinterventions",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.release_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ManualInterventionList =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod get {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::ManualIntervention;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) release_id: i32,
            pub(crate) manual_intervention_id: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/Release/releases/{}/manualinterventions/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.release_id,
                            &this.manual_intervention_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::GET);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ManualIntervention =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
    pub mod update {
        use super::models;
        use azure_core::error::ResultExt;
        type Response = models::ManualIntervention;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::ManualInterventionUpdateMetadata,
            pub(crate) project: String,
            pub(crate) release_id: i32,
            pub(crate) manual_intervention_id: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, azure_core::error::Result<Response>>
            {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url_str = &format!(
                            "{}/{}/{}/_apis/Release/releases/{}/manualinterventions/{}",
                            this.client.endpoint(),
                            &this.organization,
                            &this.project,
                            &this.release_id,
                            &this.manual_intervention_id
                        );
                        let mut url = url::Url::parse(url_str)
                            .context(azure_core::error::ErrorKind::DataConversion, "parse url")?;
                        let mut req_builder = http::request::Builder::new();
                        req_builder = req_builder.method(http::Method::PATCH);
                        req_builder = req_builder.header(
                            http::header::AUTHORIZATION,
                            &this
                                .client
                                .credential()
                                .http_authorization_header(&this.client.scopes)
                                .await?,
                        );
                        url.query_pairs_mut()
                            .append_pair("api-version", "7.1-preview");
                        req_builder = req_builder.header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req_builder = req_builder.uri(url.as_str());
                        let req = req_builder
                            .body(req_body)
                            .context(azure_core::error::ErrorKind::Other, "build request")?;
                        let rsp = this
                            .client
                            .send(req)
                            .await
                            .context(azure_core::error::ErrorKind::Io, "execute request")?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body =
                                    azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ManualIntervention =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(
                                azure_core::error::ErrorKind::HttpResponse {
                                    status: status_code.as_u16(),
                                    error_code: None,
                                },
                            )),
                        }
                    }
                })
            }
        }
    }
}
