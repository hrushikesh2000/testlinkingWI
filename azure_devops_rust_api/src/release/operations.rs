#![doc = "generated by AutoRust 0.1.0"]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
use super::{models, API_VERSION};
#[derive(Clone)]
pub struct Client {
    endpoint: String,
    credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>,
    scopes: Vec<String>,
    pipeline: azure_core::Pipeline,
}
#[derive(Clone)]
pub struct ClientBuilder {
    credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>,
    endpoint: Option<String>,
    scopes: Option<Vec<String>>,
}
pub const DEFAULT_ENDPOINT: &str = azure_core::resource_manager_endpoint::AZURE_PUBLIC_CLOUD;
impl ClientBuilder {
    pub fn new(credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>) -> Self {
        Self {
            credential,
            endpoint: None,
            scopes: None,
        }
    }
    pub fn endpoint(mut self, endpoint: impl Into<String>) -> Self {
        self.endpoint = Some(endpoint.into());
        self
    }
    pub fn scopes(mut self, scopes: &[&str]) -> Self {
        self.scopes = Some(scopes.iter().map(|scope| (*scope).to_owned()).collect());
        self
    }
    pub fn build(self) -> Client {
        let endpoint = self.endpoint.unwrap_or_else(|| DEFAULT_ENDPOINT.to_owned());
        let scopes = self
            .scopes
            .unwrap_or_else(|| vec![format!("{}/", endpoint)]);
        Client::new(endpoint, self.credential, scopes)
    }
}
impl Client {
    pub(crate) fn endpoint(&self) -> &str {
        self.endpoint.as_str()
    }
    pub(crate) fn token_credential(&self) -> &dyn azure_core::auth::TokenCredential {
        self.credential.as_ref()
    }
    pub(crate) fn scopes(&self) -> Vec<&str> {
        self.scopes.iter().map(String::as_str).collect()
    }
    pub(crate) async fn send(
        &self,
        request: impl Into<azure_core::Request>,
    ) -> Result<azure_core::Response, azure_core::Error> {
        let mut context = azure_core::Context::default();
        let mut request = request.into();
        self.pipeline.send(&mut context, &mut request).await
    }
    pub fn new(
        endpoint: impl Into<String>,
        credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>,
        scopes: Vec<String>,
    ) -> Self {
        let endpoint = endpoint.into();
        let pipeline = azure_core::Pipeline::new(
            option_env!("CARGO_PKG_NAME"),
            option_env!("CARGO_PKG_VERSION"),
            azure_core::ClientOptions::default(),
            Vec::new(),
            Vec::new(),
        );
        Self {
            endpoint,
            credential,
            scopes,
            pipeline,
        }
    }
    pub fn approvals(&self) -> approvals::Client {
        approvals::Client(self.clone())
    }
    pub fn attachments(&self) -> attachments::Client {
        attachments::Client(self.clone())
    }
    pub fn definitions(&self) -> definitions::Client {
        definitions::Client(self.clone())
    }
    pub fn deployments(&self) -> deployments::Client {
        deployments::Client(self.clone())
    }
    pub fn folders(&self) -> folders::Client {
        folders::Client(self.clone())
    }
    pub fn gates(&self) -> gates::Client {
        gates::Client(self.clone())
    }
    pub fn manual_interventions(&self) -> manual_interventions::Client {
        manual_interventions::Client(self.clone())
    }
    pub fn releases(&self) -> releases::Client {
        releases::Client(self.clone())
    }
}
#[non_exhaustive]
#[derive(Debug, thiserror :: Error)]
#[allow(non_camel_case_types)]
pub enum Error {
    #[error(transparent)]
    Approvals_List(#[from] approvals::list::Error),
    #[error(transparent)]
    Approvals_Update(#[from] approvals::update::Error),
    #[error(transparent)]
    Definitions_List(#[from] definitions::list::Error),
    #[error(transparent)]
    Definitions_Create(#[from] definitions::create::Error),
    #[error(transparent)]
    Definitions_Update(#[from] definitions::update::Error),
    #[error(transparent)]
    Definitions_Get(#[from] definitions::get::Error),
    #[error(transparent)]
    Definitions_Delete(#[from] definitions::delete::Error),
    #[error(transparent)]
    Definitions_GetReleaseDefinitionHistory(
        #[from] definitions::get_release_definition_history::Error,
    ),
    #[error(transparent)]
    Definitions_GetDefinitionRevision(#[from] definitions::get_definition_revision::Error),
    #[error(transparent)]
    Deployments_List(#[from] deployments::list::Error),
    #[error(transparent)]
    Folders_List(#[from] folders::list::Error),
    #[error(transparent)]
    Folders_Create(#[from] folders::create::Error),
    #[error(transparent)]
    Folders_Update(#[from] folders::update::Error),
    #[error(transparent)]
    Folders_Delete(#[from] folders::delete::Error),
    #[error(transparent)]
    Gates_Update(#[from] gates::update::Error),
    #[error(transparent)]
    Releases_List(#[from] releases::list::Error),
    #[error(transparent)]
    Releases_Create(#[from] releases::create::Error),
    #[error(transparent)]
    Releases_GetReleaseRevision(#[from] releases::get_release_revision::Error),
    #[error(transparent)]
    Releases_UpdateRelease(#[from] releases::update_release::Error),
    #[error(transparent)]
    Releases_UpdateReleaseResource(#[from] releases::update_release_resource::Error),
    #[error(transparent)]
    Releases_GetReleaseEnvironment(#[from] releases::get_release_environment::Error),
    #[error(transparent)]
    Releases_UpdateReleaseEnvironment(#[from] releases::update_release_environment::Error),
    #[error(transparent)]
    Attachments_GetReleaseTaskAttachments(#[from] attachments::get_release_task_attachments::Error),
    #[error(transparent)]
    Attachments_GetReleaseTaskAttachmentContent(
        #[from] attachments::get_release_task_attachment_content::Error,
    ),
    #[error(transparent)]
    Attachments_GetTaskAttachments(#[from] attachments::get_task_attachments::Error),
    #[error(transparent)]
    Attachments_GetTaskAttachmentContent(#[from] attachments::get_task_attachment_content::Error),
    #[error(transparent)]
    Releases_GetTaskLog(#[from] releases::get_task_log::Error),
    #[error(transparent)]
    Releases_GetLogs(#[from] releases::get_logs::Error),
    #[error(transparent)]
    ManualInterventions_List(#[from] manual_interventions::list::Error),
    #[error(transparent)]
    ManualInterventions_Get(#[from] manual_interventions::get::Error),
    #[error(transparent)]
    ManualInterventions_Update(#[from] manual_interventions::update::Error),
    #[error(transparent)]
    Releases_GetRelease(#[from] releases::get_release::Error),
}
pub mod approvals {
    use super::{models, API_VERSION};
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                assigned_to_filter: None,
                status_filter: None,
                release_ids_filter: None,
                type_filter: None,
                top: None,
                continuation_token: None,
                query_order: None,
                include_my_group_approvals: None,
            }
        }
        pub fn update(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::ReleaseApproval>,
            project: impl Into<String>,
            approval_id: i32,
        ) -> update::Builder {
            update::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
                approval_id,
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) assigned_to_filter: Option<String>,
            pub(crate) status_filter: Option<String>,
            pub(crate) release_ids_filter: Option<String>,
            pub(crate) type_filter: Option<String>,
            pub(crate) top: Option<i32>,
            pub(crate) continuation_token: Option<i32>,
            pub(crate) query_order: Option<String>,
            pub(crate) include_my_group_approvals: Option<bool>,
        }
        impl Builder {
            pub fn assigned_to_filter(mut self, assigned_to_filter: impl Into<String>) -> Self {
                self.assigned_to_filter = Some(assigned_to_filter.into());
                self
            }
            pub fn status_filter(mut self, status_filter: impl Into<String>) -> Self {
                self.status_filter = Some(status_filter.into());
                self
            }
            pub fn release_ids_filter(mut self, release_ids_filter: impl Into<String>) -> Self {
                self.release_ids_filter = Some(release_ids_filter.into());
                self
            }
            pub fn type_filter(mut self, type_filter: impl Into<String>) -> Self {
                self.type_filter = Some(type_filter.into());
                self
            }
            pub fn top(mut self, top: i32) -> Self {
                self.top = Some(top);
                self
            }
            pub fn continuation_token(mut self, continuation_token: i32) -> Self {
                self.continuation_token = Some(continuation_token);
                self
            }
            pub fn query_order(mut self, query_order: impl Into<String>) -> Self {
                self.query_order = Some(query_order.into());
                self
            }
            pub fn include_my_group_approvals(mut self, include_my_group_approvals: bool) -> Self {
                self.include_my_group_approvals = Some(include_my_group_approvals);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::ReleaseApprovalList, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/release/approvals",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    if let Some(assigned_to_filter) = &self.assigned_to_filter {
                        url.query_pairs_mut()
                            .append_pair("assignedToFilter", assigned_to_filter);
                    }
                    if let Some(status_filter) = &self.status_filter {
                        url.query_pairs_mut()
                            .append_pair("statusFilter", status_filter);
                    }
                    if let Some(release_ids_filter) = &self.release_ids_filter {
                        url.query_pairs_mut()
                            .append_pair("releaseIdsFilter", release_ids_filter);
                    }
                    if let Some(type_filter) = &self.type_filter {
                        url.query_pairs_mut().append_pair("typeFilter", type_filter);
                    }
                    if let Some(top) = &self.top {
                        url.query_pairs_mut().append_pair("top", &top.to_string());
                    }
                    if let Some(continuation_token) = &self.continuation_token {
                        url.query_pairs_mut()
                            .append_pair("continuationToken", &continuation_token.to_string());
                    }
                    if let Some(query_order) = &self.query_order {
                        url.query_pairs_mut().append_pair("queryOrder", query_order);
                    }
                    if let Some(include_my_group_approvals) = &self.include_my_group_approvals {
                        url.query_pairs_mut().append_pair(
                            "includeMyGroupApprovals",
                            &include_my_group_approvals.to_string(),
                        );
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::ReleaseApprovalList =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod update {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::ReleaseApproval,
            pub(crate) project: String,
            pub(crate) approval_id: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::ReleaseApproval, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/release/approvals/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.approval_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::PATCH);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    req_builder = req_builder.header("content-type", "application/json");
                    let req_body = azure_core::to_json(&self.body).map_err(Error::Serialize)?;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::ReleaseApproval =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
}
pub mod definitions {
    use super::{models, API_VERSION};
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                search_text: None,
                expand: None,
                artifact_type: None,
                artifact_source_id: None,
                top: None,
                continuation_token: None,
                query_order: None,
                path: None,
                is_exact_name_match: None,
                tag_filter: None,
                property_filters: None,
                definition_id_filter: None,
                is_deleted: None,
                search_text_contains_folder_name: None,
            }
        }
        pub fn create(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::ReleaseDefinition>,
            project: impl Into<String>,
        ) -> create::Builder {
            create::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
            }
        }
        pub fn update(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::ReleaseDefinition>,
            project: impl Into<String>,
        ) -> update::Builder {
            update::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
            }
        }
        pub fn get(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            definition_id: i32,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                definition_id,
                property_filters: None,
            }
        }
        pub fn delete(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            definition_id: i32,
        ) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                definition_id,
                comment: None,
                force_delete: None,
            }
        }
        pub fn get_release_definition_history(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            definition_id: i32,
        ) -> get_release_definition_history::Builder {
            get_release_definition_history::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                definition_id,
            }
        }
        pub fn get_definition_revision(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            definition_id: i32,
            revision: i32,
        ) -> get_definition_revision::Builder {
            get_definition_revision::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                definition_id,
                revision,
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) search_text: Option<String>,
            pub(crate) expand: Option<String>,
            pub(crate) artifact_type: Option<String>,
            pub(crate) artifact_source_id: Option<String>,
            pub(crate) top: Option<i32>,
            pub(crate) continuation_token: Option<String>,
            pub(crate) query_order: Option<String>,
            pub(crate) path: Option<String>,
            pub(crate) is_exact_name_match: Option<bool>,
            pub(crate) tag_filter: Option<String>,
            pub(crate) property_filters: Option<String>,
            pub(crate) definition_id_filter: Option<String>,
            pub(crate) is_deleted: Option<bool>,
            pub(crate) search_text_contains_folder_name: Option<bool>,
        }
        impl Builder {
            pub fn search_text(mut self, search_text: impl Into<String>) -> Self {
                self.search_text = Some(search_text.into());
                self
            }
            pub fn expand(mut self, expand: impl Into<String>) -> Self {
                self.expand = Some(expand.into());
                self
            }
            pub fn artifact_type(mut self, artifact_type: impl Into<String>) -> Self {
                self.artifact_type = Some(artifact_type.into());
                self
            }
            pub fn artifact_source_id(mut self, artifact_source_id: impl Into<String>) -> Self {
                self.artifact_source_id = Some(artifact_source_id.into());
                self
            }
            pub fn top(mut self, top: i32) -> Self {
                self.top = Some(top);
                self
            }
            pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
                self.continuation_token = Some(continuation_token.into());
                self
            }
            pub fn query_order(mut self, query_order: impl Into<String>) -> Self {
                self.query_order = Some(query_order.into());
                self
            }
            pub fn path(mut self, path: impl Into<String>) -> Self {
                self.path = Some(path.into());
                self
            }
            pub fn is_exact_name_match(mut self, is_exact_name_match: bool) -> Self {
                self.is_exact_name_match = Some(is_exact_name_match);
                self
            }
            pub fn tag_filter(mut self, tag_filter: impl Into<String>) -> Self {
                self.tag_filter = Some(tag_filter.into());
                self
            }
            pub fn property_filters(mut self, property_filters: impl Into<String>) -> Self {
                self.property_filters = Some(property_filters.into());
                self
            }
            pub fn definition_id_filter(mut self, definition_id_filter: impl Into<String>) -> Self {
                self.definition_id_filter = Some(definition_id_filter.into());
                self
            }
            pub fn is_deleted(mut self, is_deleted: bool) -> Self {
                self.is_deleted = Some(is_deleted);
                self
            }
            pub fn search_text_contains_folder_name(
                mut self,
                search_text_contains_folder_name: bool,
            ) -> Self {
                self.search_text_contains_folder_name = Some(search_text_contains_folder_name);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::ReleaseDefinitionList, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/release/definitions",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    if let Some(search_text) = &self.search_text {
                        url.query_pairs_mut().append_pair("searchText", search_text);
                    }
                    if let Some(expand) = &self.expand {
                        url.query_pairs_mut().append_pair("$expand", expand);
                    }
                    if let Some(artifact_type) = &self.artifact_type {
                        url.query_pairs_mut()
                            .append_pair("artifactType", artifact_type);
                    }
                    if let Some(artifact_source_id) = &self.artifact_source_id {
                        url.query_pairs_mut()
                            .append_pair("artifactSourceId", artifact_source_id);
                    }
                    if let Some(top) = &self.top {
                        url.query_pairs_mut().append_pair("$top", &top.to_string());
                    }
                    if let Some(continuation_token) = &self.continuation_token {
                        url.query_pairs_mut()
                            .append_pair("continuationToken", continuation_token);
                    }
                    if let Some(query_order) = &self.query_order {
                        url.query_pairs_mut().append_pair("queryOrder", query_order);
                    }
                    if let Some(path) = &self.path {
                        url.query_pairs_mut().append_pair("path", path);
                    }
                    if let Some(is_exact_name_match) = &self.is_exact_name_match {
                        url.query_pairs_mut()
                            .append_pair("isExactNameMatch", &is_exact_name_match.to_string());
                    }
                    if let Some(tag_filter) = &self.tag_filter {
                        url.query_pairs_mut().append_pair("tagFilter", tag_filter);
                    }
                    if let Some(property_filters) = &self.property_filters {
                        url.query_pairs_mut()
                            .append_pair("propertyFilters", property_filters);
                    }
                    if let Some(definition_id_filter) = &self.definition_id_filter {
                        url.query_pairs_mut()
                            .append_pair("definitionIdFilter", definition_id_filter);
                    }
                    if let Some(is_deleted) = &self.is_deleted {
                        url.query_pairs_mut()
                            .append_pair("isDeleted", &is_deleted.to_string());
                    }
                    if let Some(search_text_contains_folder_name) =
                        &self.search_text_contains_folder_name
                    {
                        url.query_pairs_mut().append_pair(
                            "searchTextContainsFolderName",
                            &search_text_contains_folder_name.to_string(),
                        );
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::ReleaseDefinitionList =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod create {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::ReleaseDefinition,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::ReleaseDefinition, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/release/definitions",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::POST);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    req_builder = req_builder.header("content-type", "application/json");
                    let req_body = azure_core::to_json(&self.body).map_err(Error::Serialize)?;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::ReleaseDefinition =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod update {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::ReleaseDefinition,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::ReleaseDefinition, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/release/definitions",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::PUT);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    req_builder = req_builder.header("content-type", "application/json");
                    let req_body = azure_core::to_json(&self.body).map_err(Error::Serialize)?;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::ReleaseDefinition =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) definition_id: i32,
            pub(crate) property_filters: Option<String>,
        }
        impl Builder {
            pub fn property_filters(mut self, property_filters: impl Into<String>) -> Self {
                self.property_filters = Some(property_filters.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::ReleaseDefinition, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/release/definitions/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.definition_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    if let Some(property_filters) = &self.property_filters {
                        url.query_pairs_mut()
                            .append_pair("propertyFilters", property_filters);
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::ReleaseDefinition =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) definition_id: i32,
            pub(crate) comment: Option<String>,
            pub(crate) force_delete: Option<bool>,
        }
        impl Builder {
            pub fn comment(mut self, comment: impl Into<String>) -> Self {
                self.comment = Some(comment.into());
                self
            }
            pub fn force_delete(mut self, force_delete: bool) -> Self {
                self.force_delete = Some(force_delete);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<(), Error>> {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/release/definitions/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.definition_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::DELETE);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    if let Some(comment) = &self.comment {
                        url.query_pairs_mut().append_pair("comment", comment);
                    }
                    if let Some(force_delete) = &self.force_delete {
                        url.query_pairs_mut()
                            .append_pair("forceDelete", &force_delete.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => Ok(()),
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_release_definition_history {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) definition_id: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::ReleaseDefinitionRevisionList, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/Release/definitions/{}/revisions",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.definition_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::ReleaseDefinitionRevisionList =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_definition_revision {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) definition_id: i32,
            pub(crate) revision: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<String, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/Release/definitions/{}/revisions/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.definition_id,
                        &self.revision
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: String = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
}
pub mod deployments {
    use super::{models, API_VERSION};
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                definition_id: None,
                definition_environment_id: None,
                created_by: None,
                min_modified_time: None,
                max_modified_time: None,
                deployment_status: None,
                operation_status: None,
                latest_attempts_only: None,
                query_order: None,
                top: None,
                continuation_token: None,
                created_for: None,
                min_started_time: None,
                max_started_time: None,
                source_branch: None,
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) definition_id: Option<i32>,
            pub(crate) definition_environment_id: Option<i32>,
            pub(crate) created_by: Option<String>,
            pub(crate) min_modified_time: Option<String>,
            pub(crate) max_modified_time: Option<String>,
            pub(crate) deployment_status: Option<String>,
            pub(crate) operation_status: Option<String>,
            pub(crate) latest_attempts_only: Option<bool>,
            pub(crate) query_order: Option<String>,
            pub(crate) top: Option<i32>,
            pub(crate) continuation_token: Option<i32>,
            pub(crate) created_for: Option<String>,
            pub(crate) min_started_time: Option<String>,
            pub(crate) max_started_time: Option<String>,
            pub(crate) source_branch: Option<String>,
        }
        impl Builder {
            pub fn definition_id(mut self, definition_id: i32) -> Self {
                self.definition_id = Some(definition_id);
                self
            }
            pub fn definition_environment_id(mut self, definition_environment_id: i32) -> Self {
                self.definition_environment_id = Some(definition_environment_id);
                self
            }
            pub fn created_by(mut self, created_by: impl Into<String>) -> Self {
                self.created_by = Some(created_by.into());
                self
            }
            pub fn min_modified_time(mut self, min_modified_time: impl Into<String>) -> Self {
                self.min_modified_time = Some(min_modified_time.into());
                self
            }
            pub fn max_modified_time(mut self, max_modified_time: impl Into<String>) -> Self {
                self.max_modified_time = Some(max_modified_time.into());
                self
            }
            pub fn deployment_status(mut self, deployment_status: impl Into<String>) -> Self {
                self.deployment_status = Some(deployment_status.into());
                self
            }
            pub fn operation_status(mut self, operation_status: impl Into<String>) -> Self {
                self.operation_status = Some(operation_status.into());
                self
            }
            pub fn latest_attempts_only(mut self, latest_attempts_only: bool) -> Self {
                self.latest_attempts_only = Some(latest_attempts_only);
                self
            }
            pub fn query_order(mut self, query_order: impl Into<String>) -> Self {
                self.query_order = Some(query_order.into());
                self
            }
            pub fn top(mut self, top: i32) -> Self {
                self.top = Some(top);
                self
            }
            pub fn continuation_token(mut self, continuation_token: i32) -> Self {
                self.continuation_token = Some(continuation_token);
                self
            }
            pub fn created_for(mut self, created_for: impl Into<String>) -> Self {
                self.created_for = Some(created_for.into());
                self
            }
            pub fn min_started_time(mut self, min_started_time: impl Into<String>) -> Self {
                self.min_started_time = Some(min_started_time.into());
                self
            }
            pub fn max_started_time(mut self, max_started_time: impl Into<String>) -> Self {
                self.max_started_time = Some(max_started_time.into());
                self
            }
            pub fn source_branch(mut self, source_branch: impl Into<String>) -> Self {
                self.source_branch = Some(source_branch.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::DeploymentList, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/release/deployments",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    if let Some(definition_id) = &self.definition_id {
                        url.query_pairs_mut()
                            .append_pair("definitionId", &definition_id.to_string());
                    }
                    if let Some(definition_environment_id) = &self.definition_environment_id {
                        url.query_pairs_mut().append_pair(
                            "definitionEnvironmentId",
                            &definition_environment_id.to_string(),
                        );
                    }
                    if let Some(created_by) = &self.created_by {
                        url.query_pairs_mut().append_pair("createdBy", created_by);
                    }
                    if let Some(min_modified_time) = &self.min_modified_time {
                        url.query_pairs_mut()
                            .append_pair("minModifiedTime", min_modified_time);
                    }
                    if let Some(max_modified_time) = &self.max_modified_time {
                        url.query_pairs_mut()
                            .append_pair("maxModifiedTime", max_modified_time);
                    }
                    if let Some(deployment_status) = &self.deployment_status {
                        url.query_pairs_mut()
                            .append_pair("deploymentStatus", deployment_status);
                    }
                    if let Some(operation_status) = &self.operation_status {
                        url.query_pairs_mut()
                            .append_pair("operationStatus", operation_status);
                    }
                    if let Some(latest_attempts_only) = &self.latest_attempts_only {
                        url.query_pairs_mut()
                            .append_pair("latestAttemptsOnly", &latest_attempts_only.to_string());
                    }
                    if let Some(query_order) = &self.query_order {
                        url.query_pairs_mut().append_pair("queryOrder", query_order);
                    }
                    if let Some(top) = &self.top {
                        url.query_pairs_mut().append_pair("$top", &top.to_string());
                    }
                    if let Some(continuation_token) = &self.continuation_token {
                        url.query_pairs_mut()
                            .append_pair("continuationToken", &continuation_token.to_string());
                    }
                    if let Some(created_for) = &self.created_for {
                        url.query_pairs_mut().append_pair("createdFor", created_for);
                    }
                    if let Some(min_started_time) = &self.min_started_time {
                        url.query_pairs_mut()
                            .append_pair("minStartedTime", min_started_time);
                    }
                    if let Some(max_started_time) = &self.max_started_time {
                        url.query_pairs_mut()
                            .append_pair("maxStartedTime", max_started_time);
                    }
                    if let Some(source_branch) = &self.source_branch {
                        url.query_pairs_mut()
                            .append_pair("sourceBranch", source_branch);
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::DeploymentList =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
}
pub mod folders {
    use super::{models, API_VERSION};
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            path: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                path: path.into(),
                query_order: None,
            }
        }
        pub fn create(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::Folder>,
            project: impl Into<String>,
            path: impl Into<String>,
        ) -> create::Builder {
            create::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
                path: path.into(),
            }
        }
        pub fn update(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::Folder>,
            project: impl Into<String>,
            path: impl Into<String>,
        ) -> update::Builder {
            update::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
                path: path.into(),
            }
        }
        pub fn delete(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            path: impl Into<String>,
        ) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                path: path.into(),
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) path: String,
            pub(crate) query_order: Option<String>,
        }
        impl Builder {
            pub fn query_order(mut self, query_order: impl Into<String>) -> Self {
                self.query_order = Some(query_order.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<models::FolderList, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/release/folders/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.path
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    if let Some(query_order) = &self.query_order {
                        url.query_pairs_mut().append_pair("queryOrder", query_order);
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::FolderList = serde_json::from_slice(&rsp_body)
                                .map_err(|source| {
                                Error::Deserialize(source, rsp_body.clone())
                            })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod create {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::Folder,
            pub(crate) project: String,
            pub(crate) path: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<models::Folder, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/release/folders/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.path
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::POST);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    req_builder = req_builder.header("content-type", "application/json");
                    let req_body = azure_core::to_json(&self.body).map_err(Error::Serialize)?;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::Folder = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod update {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::Folder,
            pub(crate) project: String,
            pub(crate) path: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<models::Folder, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/release/folders/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.path
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::PATCH);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    req_builder = req_builder.header("content-type", "application/json");
                    let req_body = azure_core::to_json(&self.body).map_err(Error::Serialize)?;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::Folder = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) path: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<(), Error>> {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/release/folders/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.path
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::DELETE);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => Ok(()),
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
}
pub mod gates {
    use super::{models, API_VERSION};
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn update(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::GateUpdateMetadata>,
            project: impl Into<String>,
            gate_step_id: i32,
        ) -> update::Builder {
            update::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
                gate_step_id,
            }
        }
    }
    pub mod update {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::GateUpdateMetadata,
            pub(crate) project: String,
            pub(crate) gate_step_id: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<models::ReleaseGates, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/release/gates/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.gate_step_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::PATCH);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    req_builder = req_builder.header("content-type", "application/json");
                    let req_body = azure_core::to_json(&self.body).map_err(Error::Serialize)?;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::ReleaseGates = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
}
pub mod releases {
    use super::{models, API_VERSION};
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                definition_id: None,
                definition_environment_id: None,
                search_text: None,
                created_by: None,
                status_filter: None,
                environment_status_filter: None,
                min_created_time: None,
                max_created_time: None,
                query_order: None,
                top: None,
                continuation_token: None,
                expand: None,
                artifact_type_id: None,
                source_id: None,
                artifact_version_id: None,
                source_branch_filter: None,
                is_deleted: None,
                tag_filter: None,
                property_filters: None,
                release_id_filter: None,
                path: None,
            }
        }
        pub fn create(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::ReleaseStartMetadata>,
            project: impl Into<String>,
        ) -> create::Builder {
            create::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
            }
        }
        pub fn get_release_revision(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            release_id: i32,
            definition_snapshot_revision: i32,
        ) -> get_release_revision::Builder {
            get_release_revision::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                release_id,
                definition_snapshot_revision,
            }
        }
        pub fn update_release(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::Release>,
            project: impl Into<String>,
            release_id: i32,
        ) -> update_release::Builder {
            update_release::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
                release_id,
            }
        }
        pub fn update_release_resource(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::ReleaseUpdateMetadata>,
            project: impl Into<String>,
            release_id: i32,
        ) -> update_release_resource::Builder {
            update_release_resource::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
                release_id,
            }
        }
        pub fn get_release_environment(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            release_id: i32,
            environment_id: i32,
        ) -> get_release_environment::Builder {
            get_release_environment::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                release_id,
                environment_id,
                expand: None,
            }
        }
        pub fn update_release_environment(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::ReleaseEnvironmentUpdateMetadata>,
            project: impl Into<String>,
            release_id: i32,
            environment_id: i32,
        ) -> update_release_environment::Builder {
            update_release_environment::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
                release_id,
                environment_id,
            }
        }
        pub fn get_task_log(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            release_id: i32,
            environment_id: i32,
            release_deploy_phase_id: i32,
            task_id: i32,
        ) -> get_task_log::Builder {
            get_task_log::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                release_id,
                environment_id,
                release_deploy_phase_id,
                task_id,
                start_line: None,
                end_line: None,
            }
        }
        pub fn get_logs(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            release_id: i32,
        ) -> get_logs::Builder {
            get_logs::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                release_id,
            }
        }
        pub fn get_release(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            release_id: i32,
        ) -> get_release::Builder {
            get_release::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                release_id,
                approval_filters: None,
                property_filters: None,
                expand: None,
                top_gate_records: None,
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) definition_id: Option<i32>,
            pub(crate) definition_environment_id: Option<i32>,
            pub(crate) search_text: Option<String>,
            pub(crate) created_by: Option<String>,
            pub(crate) status_filter: Option<String>,
            pub(crate) environment_status_filter: Option<i32>,
            pub(crate) min_created_time: Option<String>,
            pub(crate) max_created_time: Option<String>,
            pub(crate) query_order: Option<String>,
            pub(crate) top: Option<i32>,
            pub(crate) continuation_token: Option<i32>,
            pub(crate) expand: Option<String>,
            pub(crate) artifact_type_id: Option<String>,
            pub(crate) source_id: Option<String>,
            pub(crate) artifact_version_id: Option<String>,
            pub(crate) source_branch_filter: Option<String>,
            pub(crate) is_deleted: Option<bool>,
            pub(crate) tag_filter: Option<String>,
            pub(crate) property_filters: Option<String>,
            pub(crate) release_id_filter: Option<String>,
            pub(crate) path: Option<String>,
        }
        impl Builder {
            pub fn definition_id(mut self, definition_id: i32) -> Self {
                self.definition_id = Some(definition_id);
                self
            }
            pub fn definition_environment_id(mut self, definition_environment_id: i32) -> Self {
                self.definition_environment_id = Some(definition_environment_id);
                self
            }
            pub fn search_text(mut self, search_text: impl Into<String>) -> Self {
                self.search_text = Some(search_text.into());
                self
            }
            pub fn created_by(mut self, created_by: impl Into<String>) -> Self {
                self.created_by = Some(created_by.into());
                self
            }
            pub fn status_filter(mut self, status_filter: impl Into<String>) -> Self {
                self.status_filter = Some(status_filter.into());
                self
            }
            pub fn environment_status_filter(mut self, environment_status_filter: i32) -> Self {
                self.environment_status_filter = Some(environment_status_filter);
                self
            }
            pub fn min_created_time(mut self, min_created_time: impl Into<String>) -> Self {
                self.min_created_time = Some(min_created_time.into());
                self
            }
            pub fn max_created_time(mut self, max_created_time: impl Into<String>) -> Self {
                self.max_created_time = Some(max_created_time.into());
                self
            }
            pub fn query_order(mut self, query_order: impl Into<String>) -> Self {
                self.query_order = Some(query_order.into());
                self
            }
            pub fn top(mut self, top: i32) -> Self {
                self.top = Some(top);
                self
            }
            pub fn continuation_token(mut self, continuation_token: i32) -> Self {
                self.continuation_token = Some(continuation_token);
                self
            }
            pub fn expand(mut self, expand: impl Into<String>) -> Self {
                self.expand = Some(expand.into());
                self
            }
            pub fn artifact_type_id(mut self, artifact_type_id: impl Into<String>) -> Self {
                self.artifact_type_id = Some(artifact_type_id.into());
                self
            }
            pub fn source_id(mut self, source_id: impl Into<String>) -> Self {
                self.source_id = Some(source_id.into());
                self
            }
            pub fn artifact_version_id(mut self, artifact_version_id: impl Into<String>) -> Self {
                self.artifact_version_id = Some(artifact_version_id.into());
                self
            }
            pub fn source_branch_filter(mut self, source_branch_filter: impl Into<String>) -> Self {
                self.source_branch_filter = Some(source_branch_filter.into());
                self
            }
            pub fn is_deleted(mut self, is_deleted: bool) -> Self {
                self.is_deleted = Some(is_deleted);
                self
            }
            pub fn tag_filter(mut self, tag_filter: impl Into<String>) -> Self {
                self.tag_filter = Some(tag_filter.into());
                self
            }
            pub fn property_filters(mut self, property_filters: impl Into<String>) -> Self {
                self.property_filters = Some(property_filters.into());
                self
            }
            pub fn release_id_filter(mut self, release_id_filter: impl Into<String>) -> Self {
                self.release_id_filter = Some(release_id_filter.into());
                self
            }
            pub fn path(mut self, path: impl Into<String>) -> Self {
                self.path = Some(path.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<models::ReleaseList, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/release/releases",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    if let Some(definition_id) = &self.definition_id {
                        url.query_pairs_mut()
                            .append_pair("definitionId", &definition_id.to_string());
                    }
                    if let Some(definition_environment_id) = &self.definition_environment_id {
                        url.query_pairs_mut().append_pair(
                            "definitionEnvironmentId",
                            &definition_environment_id.to_string(),
                        );
                    }
                    if let Some(search_text) = &self.search_text {
                        url.query_pairs_mut().append_pair("searchText", search_text);
                    }
                    if let Some(created_by) = &self.created_by {
                        url.query_pairs_mut().append_pair("createdBy", created_by);
                    }
                    if let Some(status_filter) = &self.status_filter {
                        url.query_pairs_mut()
                            .append_pair("statusFilter", status_filter);
                    }
                    if let Some(environment_status_filter) = &self.environment_status_filter {
                        url.query_pairs_mut().append_pair(
                            "environmentStatusFilter",
                            &environment_status_filter.to_string(),
                        );
                    }
                    if let Some(min_created_time) = &self.min_created_time {
                        url.query_pairs_mut()
                            .append_pair("minCreatedTime", min_created_time);
                    }
                    if let Some(max_created_time) = &self.max_created_time {
                        url.query_pairs_mut()
                            .append_pair("maxCreatedTime", max_created_time);
                    }
                    if let Some(query_order) = &self.query_order {
                        url.query_pairs_mut().append_pair("queryOrder", query_order);
                    }
                    if let Some(top) = &self.top {
                        url.query_pairs_mut().append_pair("$top", &top.to_string());
                    }
                    if let Some(continuation_token) = &self.continuation_token {
                        url.query_pairs_mut()
                            .append_pair("continuationToken", &continuation_token.to_string());
                    }
                    if let Some(expand) = &self.expand {
                        url.query_pairs_mut().append_pair("$expand", expand);
                    }
                    if let Some(artifact_type_id) = &self.artifact_type_id {
                        url.query_pairs_mut()
                            .append_pair("artifactTypeId", artifact_type_id);
                    }
                    if let Some(source_id) = &self.source_id {
                        url.query_pairs_mut().append_pair("sourceId", source_id);
                    }
                    if let Some(artifact_version_id) = &self.artifact_version_id {
                        url.query_pairs_mut()
                            .append_pair("artifactVersionId", artifact_version_id);
                    }
                    if let Some(source_branch_filter) = &self.source_branch_filter {
                        url.query_pairs_mut()
                            .append_pair("sourceBranchFilter", source_branch_filter);
                    }
                    if let Some(is_deleted) = &self.is_deleted {
                        url.query_pairs_mut()
                            .append_pair("isDeleted", &is_deleted.to_string());
                    }
                    if let Some(tag_filter) = &self.tag_filter {
                        url.query_pairs_mut().append_pair("tagFilter", tag_filter);
                    }
                    if let Some(property_filters) = &self.property_filters {
                        url.query_pairs_mut()
                            .append_pair("propertyFilters", property_filters);
                    }
                    if let Some(release_id_filter) = &self.release_id_filter {
                        url.query_pairs_mut()
                            .append_pair("releaseIdFilter", release_id_filter);
                    }
                    if let Some(path) = &self.path {
                        url.query_pairs_mut().append_pair("path", path);
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::ReleaseList = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod create {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::ReleaseStartMetadata,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<models::Release, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/release/releases",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::POST);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    req_builder = req_builder.header("content-type", "application/json");
                    let req_body = azure_core::to_json(&self.body).map_err(Error::Serialize)?;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::Release = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_release_revision {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) release_id: i32,
            pub(crate) definition_snapshot_revision: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<String, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/release/releases/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.release_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    let definition_snapshot_revision = &self.definition_snapshot_revision;
                    url.query_pairs_mut().append_pair(
                        "definitionSnapshotRevision",
                        &definition_snapshot_revision.to_string(),
                    );
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: String = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod update_release {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::Release,
            pub(crate) project: String,
            pub(crate) release_id: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<models::Release, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/release/releases/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.release_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::PUT);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    req_builder = req_builder.header("content-type", "application/json");
                    let req_body = azure_core::to_json(&self.body).map_err(Error::Serialize)?;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::Release = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod update_release_resource {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::ReleaseUpdateMetadata,
            pub(crate) project: String,
            pub(crate) release_id: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<models::Release, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/release/releases/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.release_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::PATCH);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    req_builder = req_builder.header("content-type", "application/json");
                    let req_body = azure_core::to_json(&self.body).map_err(Error::Serialize)?;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::Release = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_release_environment {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) release_id: i32,
            pub(crate) environment_id: i32,
            pub(crate) expand: Option<String>,
        }
        impl Builder {
            pub fn expand(mut self, expand: impl Into<String>) -> Self {
                self.expand = Some(expand.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::ReleaseEnvironment, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/Release/releases/{}/environments/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.release_id,
                        &self.environment_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    if let Some(expand) = &self.expand {
                        url.query_pairs_mut().append_pair("$expand", expand);
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::ReleaseEnvironment =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod update_release_environment {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::ReleaseEnvironmentUpdateMetadata,
            pub(crate) project: String,
            pub(crate) release_id: i32,
            pub(crate) environment_id: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::ReleaseEnvironment, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/Release/releases/{}/environments/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.release_id,
                        &self.environment_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::PATCH);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    req_builder = req_builder.header("content-type", "application/json");
                    let req_body = azure_core::to_json(&self.body).map_err(Error::Serialize)?;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::ReleaseEnvironment =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_task_log {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) release_id: i32,
            pub(crate) environment_id: i32,
            pub(crate) release_deploy_phase_id: i32,
            pub(crate) task_id: i32,
            pub(crate) start_line: Option<i64>,
            pub(crate) end_line: Option<i64>,
        }
        impl Builder {
            pub fn start_line(mut self, start_line: i64) -> Self {
                self.start_line = Some(start_line);
                self
            }
            pub fn end_line(mut self, end_line: i64) -> Self {
                self.end_line = Some(end_line);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<String, Error>>
            {
                Box::pin(async move {
                    let url_str = & format ! ("{}/{}/{}/_apis/release/releases/{}/environments/{}/deployPhases/{}/tasks/{}/logs" , self . client . endpoint () , & self . organization , & self . project , & self . release_id , & self . environment_id , & self . release_deploy_phase_id , & self . task_id) ;
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    if let Some(start_line) = &self.start_line {
                        url.query_pairs_mut()
                            .append_pair("startLine", &start_line.to_string());
                    }
                    if let Some(end_line) = &self.end_line {
                        url.query_pairs_mut()
                            .append_pair("endLine", &end_line.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: String = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_logs {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) release_id: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<String, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/release/releases/{}/logs",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.release_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: String = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_release {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) release_id: i32,
            pub(crate) approval_filters: Option<String>,
            pub(crate) property_filters: Option<String>,
            pub(crate) expand: Option<String>,
            pub(crate) top_gate_records: Option<i32>,
        }
        impl Builder {
            pub fn approval_filters(mut self, approval_filters: impl Into<String>) -> Self {
                self.approval_filters = Some(approval_filters.into());
                self
            }
            pub fn property_filters(mut self, property_filters: impl Into<String>) -> Self {
                self.property_filters = Some(property_filters.into());
                self
            }
            pub fn expand(mut self, expand: impl Into<String>) -> Self {
                self.expand = Some(expand.into());
                self
            }
            pub fn top_gate_records(mut self, top_gate_records: i32) -> Self {
                self.top_gate_records = Some(top_gate_records);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<models::Release, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/release/releases/{}?",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.release_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    if let Some(approval_filters) = &self.approval_filters {
                        url.query_pairs_mut()
                            .append_pair("approvalFilters", approval_filters);
                    }
                    if let Some(property_filters) = &self.property_filters {
                        url.query_pairs_mut()
                            .append_pair("propertyFilters", property_filters);
                    }
                    if let Some(expand) = &self.expand {
                        url.query_pairs_mut().append_pair("$expand", expand);
                    }
                    if let Some(top_gate_records) = &self.top_gate_records {
                        url.query_pairs_mut()
                            .append_pair("$topGateRecords", &top_gate_records.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::Release = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
}
pub mod attachments {
    use super::{models, API_VERSION};
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get_release_task_attachments(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            release_id: i32,
            environment_id: i32,
            attempt_id: i32,
            plan_id: impl Into<String>,
            type_: impl Into<String>,
        ) -> get_release_task_attachments::Builder {
            get_release_task_attachments::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                release_id,
                environment_id,
                attempt_id,
                plan_id: plan_id.into(),
                type_: type_.into(),
            }
        }
        pub fn get_release_task_attachment_content(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            release_id: i32,
            environment_id: i32,
            attempt_id: i32,
            plan_id: impl Into<String>,
            timeline_id: impl Into<String>,
            record_id: impl Into<String>,
            type_: impl Into<String>,
            name: impl Into<String>,
        ) -> get_release_task_attachment_content::Builder {
            get_release_task_attachment_content::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                release_id,
                environment_id,
                attempt_id,
                plan_id: plan_id.into(),
                timeline_id: timeline_id.into(),
                record_id: record_id.into(),
                type_: type_.into(),
                name: name.into(),
            }
        }
        pub fn get_task_attachments(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            release_id: i32,
            environment_id: i32,
            attempt_id: i32,
            timeline_id: impl Into<String>,
            type_: impl Into<String>,
        ) -> get_task_attachments::Builder {
            get_task_attachments::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                release_id,
                environment_id,
                attempt_id,
                timeline_id: timeline_id.into(),
                type_: type_.into(),
            }
        }
        pub fn get_task_attachment_content(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            release_id: i32,
            environment_id: i32,
            attempt_id: i32,
            timeline_id: impl Into<String>,
            record_id: impl Into<String>,
            type_: impl Into<String>,
            name: impl Into<String>,
        ) -> get_task_attachment_content::Builder {
            get_task_attachment_content::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                release_id,
                environment_id,
                attempt_id,
                timeline_id: timeline_id.into(),
                record_id: record_id.into(),
                type_: type_.into(),
                name: name.into(),
            }
        }
    }
    pub mod get_release_task_attachments {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) release_id: i32,
            pub(crate) environment_id: i32,
            pub(crate) attempt_id: i32,
            pub(crate) plan_id: String,
            pub(crate) type_: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::ReleaseTaskAttachmentList, Error>,
            > {
                Box::pin(async move {
                    let url_str = & format ! ("{}/{}/{}/_apis/release/releases/{}/environments/{}/attempts/{}/plan/{}/attachments/{}" , self . client . endpoint () , & self . organization , & self . project , & self . release_id , & self . environment_id , & self . attempt_id , & self . plan_id , & self . type_) ;
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::ReleaseTaskAttachmentList =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_release_task_attachment_content {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) release_id: i32,
            pub(crate) environment_id: i32,
            pub(crate) attempt_id: i32,
            pub(crate) plan_id: String,
            pub(crate) timeline_id: String,
            pub(crate) record_id: String,
            pub(crate) type_: String,
            pub(crate) name: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<String, Error>>
            {
                Box::pin(async move {
                    let url_str = & format ! ("{}/{}/{}/_apis/release/releases/{}/environments/{}/attempts/{}/plan/{}/timelines/{}/records/{}/attachments/{}/{}" , self . client . endpoint () , & self . organization , & self . project , & self . release_id , & self . environment_id , & self . attempt_id , & self . plan_id , & self . timeline_id , & self . record_id , & self . type_ , & self . name) ;
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: String = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_task_attachments {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) release_id: i32,
            pub(crate) environment_id: i32,
            pub(crate) attempt_id: i32,
            pub(crate) timeline_id: String,
            pub(crate) type_: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::ReleaseTaskAttachmentList, Error>,
            > {
                Box::pin(async move {
                    let url_str = & format ! ("{}/{}/{}/_apis/release/releases/{}/environments/{}/attempts/{}/timelines/{}/attachments/{}" , self . client . endpoint () , & self . organization , & self . project , & self . release_id , & self . environment_id , & self . attempt_id , & self . timeline_id , & self . type_) ;
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::ReleaseTaskAttachmentList =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_task_attachment_content {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) release_id: i32,
            pub(crate) environment_id: i32,
            pub(crate) attempt_id: i32,
            pub(crate) timeline_id: String,
            pub(crate) record_id: String,
            pub(crate) type_: String,
            pub(crate) name: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<String, Error>>
            {
                Box::pin(async move {
                    let url_str = & format ! ("{}/{}/{}/_apis/release/releases/{}/environments/{}/attempts/{}/timelines/{}/records/{}/attachments/{}/{}" , self . client . endpoint () , & self . organization , & self . project , & self . release_id , & self . environment_id , & self . attempt_id , & self . timeline_id , & self . record_id , & self . type_ , & self . name) ;
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: String = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
}
pub mod manual_interventions {
    use super::{models, API_VERSION};
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            release_id: i32,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                release_id,
            }
        }
        pub fn get(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
            release_id: i32,
            manual_intervention_id: i32,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                release_id,
                manual_intervention_id,
            }
        }
        pub fn update(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::ManualInterventionUpdateMetadata>,
            project: impl Into<String>,
            release_id: i32,
            manual_intervention_id: i32,
        ) -> update::Builder {
            update::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
                release_id,
                manual_intervention_id,
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) release_id: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::ManualInterventionList, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/Release/releases/{}/manualinterventions",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.release_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::ManualInterventionList =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) release_id: i32,
            pub(crate) manual_intervention_id: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::ManualIntervention, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/Release/releases/{}/manualinterventions/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.release_id,
                        &self.manual_intervention_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::ManualIntervention =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod update {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::ManualInterventionUpdateMetadata,
            pub(crate) project: String,
            pub(crate) release_id: i32,
            pub(crate) manual_intervention_id: i32,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::ManualIntervention, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/Release/releases/{}/manualinterventions/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.release_id,
                        &self.manual_intervention_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::PATCH);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    req_builder = req_builder.header("content-type", "application/json");
                    let req_body = azure_core::to_json(&self.body).map_err(Error::Serialize)?;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::ManualIntervention =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
}
