#![doc = "generated by AutoRust 0.1.0"]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
use super::{models, API_VERSION};
#[derive(Clone)]
pub struct Client {
    endpoint: String,
    credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>,
    scopes: Vec<String>,
    pipeline: azure_core::Pipeline,
}
#[derive(Clone)]
pub struct ClientBuilder {
    credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>,
    endpoint: Option<String>,
    scopes: Option<Vec<String>>,
}
pub const DEFAULT_ENDPOINT: &str = azure_core::resource_manager_endpoint::AZURE_PUBLIC_CLOUD;
impl ClientBuilder {
    pub fn new(credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>) -> Self {
        Self {
            credential,
            endpoint: None,
            scopes: None,
        }
    }
    pub fn endpoint(mut self, endpoint: impl Into<String>) -> Self {
        self.endpoint = Some(endpoint.into());
        self
    }
    pub fn scopes(mut self, scopes: &[&str]) -> Self {
        self.scopes = Some(scopes.iter().map(|scope| (*scope).to_owned()).collect());
        self
    }
    pub fn build(self) -> Client {
        let endpoint = self.endpoint.unwrap_or_else(|| DEFAULT_ENDPOINT.to_owned());
        let scopes = self
            .scopes
            .unwrap_or_else(|| vec![format!("{}/", endpoint)]);
        Client::new(endpoint, self.credential, scopes)
    }
}
impl Client {
    pub(crate) fn endpoint(&self) -> &str {
        self.endpoint.as_str()
    }
    pub(crate) fn token_credential(&self) -> &dyn azure_core::auth::TokenCredential {
        self.credential.as_ref()
    }
    pub(crate) fn scopes(&self) -> Vec<&str> {
        self.scopes.iter().map(String::as_str).collect()
    }
    pub(crate) async fn send(
        &self,
        request: impl Into<azure_core::Request>,
    ) -> Result<azure_core::Response, azure_core::Error> {
        let mut context = azure_core::Context::default();
        let mut request = request.into();
        self.pipeline.send(&mut context, &mut request).await
    }
    pub fn new(
        endpoint: impl Into<String>,
        credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>,
        scopes: Vec<String>,
    ) -> Self {
        let endpoint = endpoint.into();
        let pipeline = azure_core::Pipeline::new(
            option_env!("CARGO_PKG_NAME"),
            option_env!("CARGO_PKG_VERSION"),
            azure_core::ClientOptions::default(),
            Vec::new(),
            Vec::new(),
        );
        Self {
            endpoint,
            credential,
            scopes,
            pipeline,
        }
    }
    pub fn artifact_details(&self) -> artifact_details::Client {
        artifact_details::Client(self.clone())
    }
    pub fn change_tracking(&self) -> change_tracking::Client {
        change_tracking::Client(self.clone())
    }
    pub fn feed_management(&self) -> feed_management::Client {
        feed_management::Client(self.clone())
    }
    pub fn feed_recycle_bin(&self) -> feed_recycle_bin::Client {
        feed_recycle_bin::Client(self.clone())
    }
    pub fn provenance(&self) -> provenance::Client {
        provenance::Client(self.clone())
    }
    pub fn recycle_bin(&self) -> recycle_bin::Client {
        recycle_bin::Client(self.clone())
    }
    pub fn retention_policies(&self) -> retention_policies::Client {
        retention_policies::Client(self.clone())
    }
    pub fn service_settings(&self) -> service_settings::Client {
        service_settings::Client(self.clone())
    }
}
#[non_exhaustive]
#[derive(Debug, thiserror :: Error)]
#[allow(non_camel_case_types)]
pub enum Error {
    #[error(transparent)]
    ServiceSettings_GetGlobalPermissions(#[from] service_settings::get_global_permissions::Error),
    #[error(transparent)]
    ServiceSettings_SetGlobalPermissions(#[from] service_settings::set_global_permissions::Error),
    #[error(transparent)]
    ChangeTracking_GetFeedChanges(#[from] change_tracking::get_feed_changes::Error),
    #[error(transparent)]
    ChangeTracking_GetFeedChange(#[from] change_tracking::get_feed_change::Error),
    #[error(transparent)]
    FeedRecycleBin_List(#[from] feed_recycle_bin::list::Error),
    #[error(transparent)]
    FeedRecycleBin_RestoreDeletedFeed(#[from] feed_recycle_bin::restore_deleted_feed::Error),
    #[error(transparent)]
    FeedRecycleBin_PermanentDeleteFeed(#[from] feed_recycle_bin::permanent_delete_feed::Error),
    #[error(transparent)]
    FeedManagement_GetFeeds(#[from] feed_management::get_feeds::Error),
    #[error(transparent)]
    FeedManagement_CreateFeed(#[from] feed_management::create_feed::Error),
    #[error(transparent)]
    FeedManagement_GetFeed(#[from] feed_management::get_feed::Error),
    #[error(transparent)]
    FeedManagement_UpdateFeed(#[from] feed_management::update_feed::Error),
    #[error(transparent)]
    FeedManagement_DeleteFeed(#[from] feed_management::delete_feed::Error),
    #[error(transparent)]
    ChangeTracking_GetPackageChanges(#[from] change_tracking::get_package_changes::Error),
    #[error(transparent)]
    ArtifactDetails_QueryPackageMetrics(#[from] artifact_details::query_package_metrics::Error),
    #[error(transparent)]
    ArtifactDetails_GetPackages(#[from] artifact_details::get_packages::Error),
    #[error(transparent)]
    ArtifactDetails_GetPackage(#[from] artifact_details::get_package::Error),
    #[error(transparent)]
    ArtifactDetails_QueryPackageVersionMetrics(
        #[from] artifact_details::query_package_version_metrics::Error,
    ),
    #[error(transparent)]
    ArtifactDetails_GetPackageVersions(#[from] artifact_details::get_package_versions::Error),
    #[error(transparent)]
    ArtifactDetails_GetPackageVersion(#[from] artifact_details::get_package_version::Error),
    #[error(transparent)]
    ArtifactDetails_GetPackageVersionProvenance(
        #[from] artifact_details::get_package_version_provenance::Error,
    ),
    #[error(transparent)]
    FeedManagement_GetFeedPermissions(#[from] feed_management::get_feed_permissions::Error),
    #[error(transparent)]
    FeedManagement_SetFeedPermissions(#[from] feed_management::set_feed_permissions::Error),
    #[error(transparent)]
    RecycleBin_GetRecycleBinPackages(#[from] recycle_bin::get_recycle_bin_packages::Error),
    #[error(transparent)]
    RecycleBin_EmptyRecycleBin(#[from] recycle_bin::empty_recycle_bin::Error),
    #[error(transparent)]
    RecycleBin_GetRecycleBinPackage(#[from] recycle_bin::get_recycle_bin_package::Error),
    #[error(transparent)]
    RecycleBin_GetRecycleBinPackageVersions(
        #[from] recycle_bin::get_recycle_bin_package_versions::Error,
    ),
    #[error(transparent)]
    RecycleBin_GetRecycleBinPackageVersion(
        #[from] recycle_bin::get_recycle_bin_package_version::Error,
    ),
    #[error(transparent)]
    RetentionPolicies_GetRetentionPolicy(#[from] retention_policies::get_retention_policy::Error),
    #[error(transparent)]
    RetentionPolicies_SetRetentionPolicy(#[from] retention_policies::set_retention_policy::Error),
    #[error(transparent)]
    RetentionPolicies_DeleteRetentionPolicy(
        #[from] retention_policies::delete_retention_policy::Error,
    ),
    #[error(transparent)]
    FeedManagement_GetFeedViews(#[from] feed_management::get_feed_views::Error),
    #[error(transparent)]
    FeedManagement_CreateFeedView(#[from] feed_management::create_feed_view::Error),
    #[error(transparent)]
    FeedManagement_GetFeedView(#[from] feed_management::get_feed_view::Error),
    #[error(transparent)]
    FeedManagement_UpdateFeedView(#[from] feed_management::update_feed_view::Error),
    #[error(transparent)]
    FeedManagement_DeleteFeedView(#[from] feed_management::delete_feed_view::Error),
    #[error(transparent)]
    ArtifactDetails_GetBadge(#[from] artifact_details::get_badge::Error),
    #[error(transparent)]
    Provenance_CreateSession(#[from] provenance::create_session::Error),
}
pub mod service_settings {
    use super::{models, API_VERSION};
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get_global_permissions(
            &self,
            organization: impl Into<String>,
        ) -> get_global_permissions::Builder {
            get_global_permissions::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                include_ids: None,
            }
        }
        pub fn set_global_permissions(
            &self,
            organization: impl Into<String>,
            body: impl Into<Vec<models::GlobalPermission>>,
        ) -> set_global_permissions::Builder {
            set_global_permissions::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
            }
        }
    }
    pub mod get_global_permissions {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) include_ids: Option<bool>,
        }
        impl Builder {
            pub fn include_ids(mut self, include_ids: bool) -> Self {
                self.include_ids = Some(include_ids);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::GlobalPermissionList, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/_apis/packaging/globalpermissions",
                        self.client.endpoint(),
                        &self.organization
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    if let Some(include_ids) = &self.include_ids {
                        url.query_pairs_mut()
                            .append_pair("includeIds", &include_ids.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::GlobalPermissionList =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod set_global_permissions {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: Vec<models::GlobalPermission>,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::GlobalPermissionList, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/_apis/packaging/globalpermissions",
                        self.client.endpoint(),
                        &self.organization
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::PATCH);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    req_builder = req_builder.header("content-type", "application/json");
                    let req_body = azure_core::to_json(&self.body).map_err(Error::Serialize)?;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::GlobalPermissionList =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
}
pub mod change_tracking {
    use super::{models, API_VERSION};
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get_feed_changes(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
        ) -> get_feed_changes::Builder {
            get_feed_changes::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                include_deleted: None,
                continuation_token: None,
                batch_size: None,
            }
        }
        pub fn get_feed_change(
            &self,
            organization: impl Into<String>,
            feed_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_feed_change::Builder {
            get_feed_change::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                feed_id: feed_id.into(),
                project: project.into(),
            }
        }
        pub fn get_package_changes(
            &self,
            organization: impl Into<String>,
            feed_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_package_changes::Builder {
            get_package_changes::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                feed_id: feed_id.into(),
                project: project.into(),
                continuation_token: None,
                batch_size: None,
            }
        }
    }
    pub mod get_feed_changes {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) include_deleted: Option<bool>,
            pub(crate) continuation_token: Option<i64>,
            pub(crate) batch_size: Option<i32>,
        }
        impl Builder {
            pub fn include_deleted(mut self, include_deleted: bool) -> Self {
                self.include_deleted = Some(include_deleted);
                self
            }
            pub fn continuation_token(mut self, continuation_token: i64) -> Self {
                self.continuation_token = Some(continuation_token);
                self
            }
            pub fn batch_size(mut self, batch_size: i32) -> Self {
                self.batch_size = Some(batch_size);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::FeedChangesResponse, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/feedchanges",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    if let Some(include_deleted) = &self.include_deleted {
                        url.query_pairs_mut()
                            .append_pair("includeDeleted", &include_deleted.to_string());
                    }
                    if let Some(continuation_token) = &self.continuation_token {
                        url.query_pairs_mut()
                            .append_pair("continuationToken", &continuation_token.to_string());
                    }
                    if let Some(batch_size) = &self.batch_size {
                        url.query_pairs_mut()
                            .append_pair("batchSize", &batch_size.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::FeedChangesResponse =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_feed_change {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) feed_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<models::FeedChange, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/feedchanges/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::FeedChange = serde_json::from_slice(&rsp_body)
                                .map_err(|source| {
                                Error::Deserialize(source, rsp_body.clone())
                            })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_package_changes {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) feed_id: String,
            pub(crate) project: String,
            pub(crate) continuation_token: Option<i64>,
            pub(crate) batch_size: Option<i32>,
        }
        impl Builder {
            pub fn continuation_token(mut self, continuation_token: i64) -> Self {
                self.continuation_token = Some(continuation_token);
                self
            }
            pub fn batch_size(mut self, batch_size: i32) -> Self {
                self.batch_size = Some(batch_size);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::PackageChangesResponse, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/Feeds/{}/packagechanges",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    if let Some(continuation_token) = &self.continuation_token {
                        url.query_pairs_mut()
                            .append_pair("continuationToken", &continuation_token.to_string());
                    }
                    if let Some(batch_size) = &self.batch_size {
                        url.query_pairs_mut()
                            .append_pair("batchSize", &batch_size.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::PackageChangesResponse =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
}
pub mod feed_recycle_bin {
    use super::{models, API_VERSION};
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
        ) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
            }
        }
        pub fn restore_deleted_feed(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::JsonPatchDocument>,
            feed_id: impl Into<String>,
            project: impl Into<String>,
        ) -> restore_deleted_feed::Builder {
            restore_deleted_feed::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                feed_id: feed_id.into(),
                project: project.into(),
            }
        }
        pub fn permanent_delete_feed(
            &self,
            organization: impl Into<String>,
            feed_id: impl Into<String>,
            project: impl Into<String>,
        ) -> permanent_delete_feed::Builder {
            permanent_delete_feed::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                feed_id: feed_id.into(),
                project: project.into(),
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<models::FeedList, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/feedrecyclebin",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::FeedList = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod restore_deleted_feed {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::JsonPatchDocument,
            pub(crate) feed_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<(), Error>> {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/feedrecyclebin/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::PATCH);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    req_builder = req_builder.header("content-type", "application/json");
                    let req_body = azure_core::to_json(&self.body).map_err(Error::Serialize)?;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => Ok(()),
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod permanent_delete_feed {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) feed_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<(), Error>> {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/feedrecyclebin/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::DELETE);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => Ok(()),
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
}
pub mod feed_management {
    use super::{models, API_VERSION};
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get_feeds(
            &self,
            organization: impl Into<String>,
            project: impl Into<String>,
        ) -> get_feeds::Builder {
            get_feeds::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                project: project.into(),
                feed_role: None,
                include_deleted_upstreams: None,
                include_urls: None,
            }
        }
        pub fn create_feed(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::Feed>,
            project: impl Into<String>,
        ) -> create_feed::Builder {
            create_feed::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                project: project.into(),
            }
        }
        pub fn get_feed(
            &self,
            organization: impl Into<String>,
            feed_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_feed::Builder {
            get_feed::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                feed_id: feed_id.into(),
                project: project.into(),
                include_deleted_upstreams: None,
            }
        }
        pub fn update_feed(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::FeedUpdate>,
            feed_id: impl Into<String>,
            project: impl Into<String>,
        ) -> update_feed::Builder {
            update_feed::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                feed_id: feed_id.into(),
                project: project.into(),
            }
        }
        pub fn delete_feed(
            &self,
            organization: impl Into<String>,
            feed_id: impl Into<String>,
            project: impl Into<String>,
        ) -> delete_feed::Builder {
            delete_feed::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                feed_id: feed_id.into(),
                project: project.into(),
            }
        }
        pub fn get_feed_permissions(
            &self,
            organization: impl Into<String>,
            feed_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_feed_permissions::Builder {
            get_feed_permissions::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                feed_id: feed_id.into(),
                project: project.into(),
                include_ids: None,
                exclude_inherited_permissions: None,
                identity_descriptor: None,
                include_deleted_feeds: None,
            }
        }
        pub fn set_feed_permissions(
            &self,
            organization: impl Into<String>,
            body: impl Into<Vec<models::FeedPermission>>,
            feed_id: impl Into<String>,
            project: impl Into<String>,
        ) -> set_feed_permissions::Builder {
            set_feed_permissions::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                feed_id: feed_id.into(),
                project: project.into(),
            }
        }
        pub fn get_feed_views(
            &self,
            organization: impl Into<String>,
            feed_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_feed_views::Builder {
            get_feed_views::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                feed_id: feed_id.into(),
                project: project.into(),
            }
        }
        pub fn create_feed_view(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::FeedView>,
            feed_id: impl Into<String>,
            project: impl Into<String>,
        ) -> create_feed_view::Builder {
            create_feed_view::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                feed_id: feed_id.into(),
                project: project.into(),
            }
        }
        pub fn get_feed_view(
            &self,
            organization: impl Into<String>,
            feed_id: impl Into<String>,
            view_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_feed_view::Builder {
            get_feed_view::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                feed_id: feed_id.into(),
                view_id: view_id.into(),
                project: project.into(),
            }
        }
        pub fn update_feed_view(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::FeedView>,
            feed_id: impl Into<String>,
            view_id: impl Into<String>,
            project: impl Into<String>,
        ) -> update_feed_view::Builder {
            update_feed_view::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                feed_id: feed_id.into(),
                view_id: view_id.into(),
                project: project.into(),
            }
        }
        pub fn delete_feed_view(
            &self,
            organization: impl Into<String>,
            feed_id: impl Into<String>,
            view_id: impl Into<String>,
            project: impl Into<String>,
        ) -> delete_feed_view::Builder {
            delete_feed_view::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                feed_id: feed_id.into(),
                view_id: view_id.into(),
                project: project.into(),
            }
        }
    }
    pub mod get_feeds {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) project: String,
            pub(crate) feed_role: Option<String>,
            pub(crate) include_deleted_upstreams: Option<bool>,
            pub(crate) include_urls: Option<bool>,
        }
        impl Builder {
            pub fn feed_role(mut self, feed_role: impl Into<String>) -> Self {
                self.feed_role = Some(feed_role.into());
                self
            }
            pub fn include_deleted_upstreams(mut self, include_deleted_upstreams: bool) -> Self {
                self.include_deleted_upstreams = Some(include_deleted_upstreams);
                self
            }
            pub fn include_urls(mut self, include_urls: bool) -> Self {
                self.include_urls = Some(include_urls);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<models::FeedList, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/feeds",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    if let Some(feed_role) = &self.feed_role {
                        url.query_pairs_mut().append_pair("feedRole", feed_role);
                    }
                    if let Some(include_deleted_upstreams) = &self.include_deleted_upstreams {
                        url.query_pairs_mut().append_pair(
                            "includeDeletedUpstreams",
                            &include_deleted_upstreams.to_string(),
                        );
                    }
                    if let Some(include_urls) = &self.include_urls {
                        url.query_pairs_mut()
                            .append_pair("includeUrls", &include_urls.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::FeedList = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod create_feed {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::Feed,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<models::Feed, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/feeds",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::POST);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    req_builder = req_builder.header("content-type", "application/json");
                    let req_body = azure_core::to_json(&self.body).map_err(Error::Serialize)?;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::Feed = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_feed {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) feed_id: String,
            pub(crate) project: String,
            pub(crate) include_deleted_upstreams: Option<bool>,
        }
        impl Builder {
            pub fn include_deleted_upstreams(mut self, include_deleted_upstreams: bool) -> Self {
                self.include_deleted_upstreams = Some(include_deleted_upstreams);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<models::Feed, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/feeds/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    if let Some(include_deleted_upstreams) = &self.include_deleted_upstreams {
                        url.query_pairs_mut().append_pair(
                            "includeDeletedUpstreams",
                            &include_deleted_upstreams.to_string(),
                        );
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::Feed = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod update_feed {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::FeedUpdate,
            pub(crate) feed_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<models::Feed, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/feeds/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::PATCH);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    req_builder = req_builder.header("content-type", "application/json");
                    let req_body = azure_core::to_json(&self.body).map_err(Error::Serialize)?;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::Feed = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod delete_feed {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) feed_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<(), Error>> {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/feeds/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::DELETE);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => Ok(()),
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_feed_permissions {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) feed_id: String,
            pub(crate) project: String,
            pub(crate) include_ids: Option<bool>,
            pub(crate) exclude_inherited_permissions: Option<bool>,
            pub(crate) identity_descriptor: Option<String>,
            pub(crate) include_deleted_feeds: Option<bool>,
        }
        impl Builder {
            pub fn include_ids(mut self, include_ids: bool) -> Self {
                self.include_ids = Some(include_ids);
                self
            }
            pub fn exclude_inherited_permissions(
                mut self,
                exclude_inherited_permissions: bool,
            ) -> Self {
                self.exclude_inherited_permissions = Some(exclude_inherited_permissions);
                self
            }
            pub fn identity_descriptor(mut self, identity_descriptor: impl Into<String>) -> Self {
                self.identity_descriptor = Some(identity_descriptor.into());
                self
            }
            pub fn include_deleted_feeds(mut self, include_deleted_feeds: bool) -> Self {
                self.include_deleted_feeds = Some(include_deleted_feeds);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::FeedPermissionList, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/Feeds/{}/permissions",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    if let Some(include_ids) = &self.include_ids {
                        url.query_pairs_mut()
                            .append_pair("includeIds", &include_ids.to_string());
                    }
                    if let Some(exclude_inherited_permissions) = &self.exclude_inherited_permissions
                    {
                        url.query_pairs_mut().append_pair(
                            "excludeInheritedPermissions",
                            &exclude_inherited_permissions.to_string(),
                        );
                    }
                    if let Some(identity_descriptor) = &self.identity_descriptor {
                        url.query_pairs_mut()
                            .append_pair("identityDescriptor", identity_descriptor);
                    }
                    if let Some(include_deleted_feeds) = &self.include_deleted_feeds {
                        url.query_pairs_mut()
                            .append_pair("includeDeletedFeeds", &include_deleted_feeds.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::FeedPermissionList =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod set_feed_permissions {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: Vec<models::FeedPermission>,
            pub(crate) feed_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::FeedPermissionList, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/Feeds/{}/permissions",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::PATCH);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    req_builder = req_builder.header("content-type", "application/json");
                    let req_body = azure_core::to_json(&self.body).map_err(Error::Serialize)?;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::FeedPermissionList =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_feed_views {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) feed_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<models::FeedViewList, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/Feeds/{}/views",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::FeedViewList = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod create_feed_view {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::FeedView,
            pub(crate) feed_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<models::FeedView, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/Feeds/{}/views",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::POST);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    req_builder = req_builder.header("content-type", "application/json");
                    let req_body = azure_core::to_json(&self.body).map_err(Error::Serialize)?;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::FeedView = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_feed_view {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) feed_id: String,
            pub(crate) view_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<models::FeedView, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/Feeds/{}/views/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id,
                        &self.view_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::FeedView = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod update_feed_view {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::FeedView,
            pub(crate) feed_id: String,
            pub(crate) view_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<models::FeedView, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/Feeds/{}/views/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id,
                        &self.view_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::PATCH);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    req_builder = req_builder.header("content-type", "application/json");
                    let req_body = azure_core::to_json(&self.body).map_err(Error::Serialize)?;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::FeedView = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod delete_feed_view {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) feed_id: String,
            pub(crate) view_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<(), Error>> {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/Feeds/{}/views/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id,
                        &self.view_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::DELETE);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => Ok(()),
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
}
pub mod artifact_details {
    use super::{models, API_VERSION};
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn query_package_metrics(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::PackageMetricsQuery>,
            feed_id: impl Into<String>,
            project: impl Into<String>,
        ) -> query_package_metrics::Builder {
            query_package_metrics::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                feed_id: feed_id.into(),
                project: project.into(),
            }
        }
        pub fn get_packages(
            &self,
            organization: impl Into<String>,
            feed_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_packages::Builder {
            get_packages::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                feed_id: feed_id.into(),
                project: project.into(),
                protocol_type: None,
                package_name_query: None,
                normalized_package_name: None,
                include_urls: None,
                include_all_versions: None,
                is_listed: None,
                get_top_package_versions: None,
                is_release: None,
                include_description: None,
                top: None,
                skip: None,
                include_deleted: None,
                is_cached: None,
                direct_upstream_id: None,
            }
        }
        pub fn get_package(
            &self,
            organization: impl Into<String>,
            feed_id: impl Into<String>,
            package_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_package::Builder {
            get_package::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                feed_id: feed_id.into(),
                package_id: package_id.into(),
                project: project.into(),
                include_all_versions: None,
                include_urls: None,
                is_listed: None,
                is_release: None,
                include_deleted: None,
                include_description: None,
            }
        }
        pub fn query_package_version_metrics(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::PackageVersionMetricsQuery>,
            feed_id: impl Into<String>,
            package_id: impl Into<String>,
            project: impl Into<String>,
        ) -> query_package_version_metrics::Builder {
            query_package_version_metrics::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                feed_id: feed_id.into(),
                package_id: package_id.into(),
                project: project.into(),
            }
        }
        pub fn get_package_versions(
            &self,
            organization: impl Into<String>,
            feed_id: impl Into<String>,
            package_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_package_versions::Builder {
            get_package_versions::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                feed_id: feed_id.into(),
                package_id: package_id.into(),
                project: project.into(),
                include_urls: None,
                is_listed: None,
                is_deleted: None,
            }
        }
        pub fn get_package_version(
            &self,
            organization: impl Into<String>,
            feed_id: impl Into<String>,
            package_id: impl Into<String>,
            package_version_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_package_version::Builder {
            get_package_version::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                feed_id: feed_id.into(),
                package_id: package_id.into(),
                package_version_id: package_version_id.into(),
                project: project.into(),
                include_urls: None,
                is_listed: None,
                is_deleted: None,
            }
        }
        pub fn get_package_version_provenance(
            &self,
            organization: impl Into<String>,
            feed_id: impl Into<String>,
            package_id: impl Into<String>,
            package_version_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_package_version_provenance::Builder {
            get_package_version_provenance::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                feed_id: feed_id.into(),
                package_id: package_id.into(),
                package_version_id: package_version_id.into(),
                project: project.into(),
            }
        }
        pub fn get_badge(
            &self,
            organization: impl Into<String>,
            feed_id: impl Into<String>,
            package_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_badge::Builder {
            get_badge::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                feed_id: feed_id.into(),
                package_id: package_id.into(),
                project: project.into(),
            }
        }
    }
    pub mod query_package_metrics {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::PackageMetricsQuery,
            pub(crate) feed_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::PackageMetricsList, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/Feeds/{}/packagemetricsbatch",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::POST);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    req_builder = req_builder.header("content-type", "application/json");
                    let req_body = azure_core::to_json(&self.body).map_err(Error::Serialize)?;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::PackageMetricsList =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_packages {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) feed_id: String,
            pub(crate) project: String,
            pub(crate) protocol_type: Option<String>,
            pub(crate) package_name_query: Option<String>,
            pub(crate) normalized_package_name: Option<String>,
            pub(crate) include_urls: Option<bool>,
            pub(crate) include_all_versions: Option<bool>,
            pub(crate) is_listed: Option<bool>,
            pub(crate) get_top_package_versions: Option<bool>,
            pub(crate) is_release: Option<bool>,
            pub(crate) include_description: Option<bool>,
            pub(crate) top: Option<i32>,
            pub(crate) skip: Option<i32>,
            pub(crate) include_deleted: Option<bool>,
            pub(crate) is_cached: Option<bool>,
            pub(crate) direct_upstream_id: Option<String>,
        }
        impl Builder {
            pub fn protocol_type(mut self, protocol_type: impl Into<String>) -> Self {
                self.protocol_type = Some(protocol_type.into());
                self
            }
            pub fn package_name_query(mut self, package_name_query: impl Into<String>) -> Self {
                self.package_name_query = Some(package_name_query.into());
                self
            }
            pub fn normalized_package_name(
                mut self,
                normalized_package_name: impl Into<String>,
            ) -> Self {
                self.normalized_package_name = Some(normalized_package_name.into());
                self
            }
            pub fn include_urls(mut self, include_urls: bool) -> Self {
                self.include_urls = Some(include_urls);
                self
            }
            pub fn include_all_versions(mut self, include_all_versions: bool) -> Self {
                self.include_all_versions = Some(include_all_versions);
                self
            }
            pub fn is_listed(mut self, is_listed: bool) -> Self {
                self.is_listed = Some(is_listed);
                self
            }
            pub fn get_top_package_versions(mut self, get_top_package_versions: bool) -> Self {
                self.get_top_package_versions = Some(get_top_package_versions);
                self
            }
            pub fn is_release(mut self, is_release: bool) -> Self {
                self.is_release = Some(is_release);
                self
            }
            pub fn include_description(mut self, include_description: bool) -> Self {
                self.include_description = Some(include_description);
                self
            }
            pub fn top(mut self, top: i32) -> Self {
                self.top = Some(top);
                self
            }
            pub fn skip(mut self, skip: i32) -> Self {
                self.skip = Some(skip);
                self
            }
            pub fn include_deleted(mut self, include_deleted: bool) -> Self {
                self.include_deleted = Some(include_deleted);
                self
            }
            pub fn is_cached(mut self, is_cached: bool) -> Self {
                self.is_cached = Some(is_cached);
                self
            }
            pub fn direct_upstream_id(mut self, direct_upstream_id: impl Into<String>) -> Self {
                self.direct_upstream_id = Some(direct_upstream_id.into());
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<models::PackageList, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/Feeds/{}/packages",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    if let Some(protocol_type) = &self.protocol_type {
                        url.query_pairs_mut()
                            .append_pair("protocolType", protocol_type);
                    }
                    if let Some(package_name_query) = &self.package_name_query {
                        url.query_pairs_mut()
                            .append_pair("packageNameQuery", package_name_query);
                    }
                    if let Some(normalized_package_name) = &self.normalized_package_name {
                        url.query_pairs_mut()
                            .append_pair("normalizedPackageName", normalized_package_name);
                    }
                    if let Some(include_urls) = &self.include_urls {
                        url.query_pairs_mut()
                            .append_pair("includeUrls", &include_urls.to_string());
                    }
                    if let Some(include_all_versions) = &self.include_all_versions {
                        url.query_pairs_mut()
                            .append_pair("includeAllVersions", &include_all_versions.to_string());
                    }
                    if let Some(is_listed) = &self.is_listed {
                        url.query_pairs_mut()
                            .append_pair("isListed", &is_listed.to_string());
                    }
                    if let Some(get_top_package_versions) = &self.get_top_package_versions {
                        url.query_pairs_mut().append_pair(
                            "getTopPackageVersions",
                            &get_top_package_versions.to_string(),
                        );
                    }
                    if let Some(is_release) = &self.is_release {
                        url.query_pairs_mut()
                            .append_pair("isRelease", &is_release.to_string());
                    }
                    if let Some(include_description) = &self.include_description {
                        url.query_pairs_mut()
                            .append_pair("includeDescription", &include_description.to_string());
                    }
                    if let Some(top) = &self.top {
                        url.query_pairs_mut().append_pair("$top", &top.to_string());
                    }
                    if let Some(skip) = &self.skip {
                        url.query_pairs_mut()
                            .append_pair("$skip", &skip.to_string());
                    }
                    if let Some(include_deleted) = &self.include_deleted {
                        url.query_pairs_mut()
                            .append_pair("includeDeleted", &include_deleted.to_string());
                    }
                    if let Some(is_cached) = &self.is_cached {
                        url.query_pairs_mut()
                            .append_pair("isCached", &is_cached.to_string());
                    }
                    if let Some(direct_upstream_id) = &self.direct_upstream_id {
                        url.query_pairs_mut()
                            .append_pair("directUpstreamId", direct_upstream_id);
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::PackageList = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_package {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) feed_id: String,
            pub(crate) package_id: String,
            pub(crate) project: String,
            pub(crate) include_all_versions: Option<bool>,
            pub(crate) include_urls: Option<bool>,
            pub(crate) is_listed: Option<bool>,
            pub(crate) is_release: Option<bool>,
            pub(crate) include_deleted: Option<bool>,
            pub(crate) include_description: Option<bool>,
        }
        impl Builder {
            pub fn include_all_versions(mut self, include_all_versions: bool) -> Self {
                self.include_all_versions = Some(include_all_versions);
                self
            }
            pub fn include_urls(mut self, include_urls: bool) -> Self {
                self.include_urls = Some(include_urls);
                self
            }
            pub fn is_listed(mut self, is_listed: bool) -> Self {
                self.is_listed = Some(is_listed);
                self
            }
            pub fn is_release(mut self, is_release: bool) -> Self {
                self.is_release = Some(is_release);
                self
            }
            pub fn include_deleted(mut self, include_deleted: bool) -> Self {
                self.include_deleted = Some(include_deleted);
                self
            }
            pub fn include_description(mut self, include_description: bool) -> Self {
                self.include_description = Some(include_description);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<models::Package, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/Feeds/{}/packages/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id,
                        &self.package_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    if let Some(include_all_versions) = &self.include_all_versions {
                        url.query_pairs_mut()
                            .append_pair("includeAllVersions", &include_all_versions.to_string());
                    }
                    if let Some(include_urls) = &self.include_urls {
                        url.query_pairs_mut()
                            .append_pair("includeUrls", &include_urls.to_string());
                    }
                    if let Some(is_listed) = &self.is_listed {
                        url.query_pairs_mut()
                            .append_pair("isListed", &is_listed.to_string());
                    }
                    if let Some(is_release) = &self.is_release {
                        url.query_pairs_mut()
                            .append_pair("isRelease", &is_release.to_string());
                    }
                    if let Some(include_deleted) = &self.include_deleted {
                        url.query_pairs_mut()
                            .append_pair("includeDeleted", &include_deleted.to_string());
                    }
                    if let Some(include_description) = &self.include_description {
                        url.query_pairs_mut()
                            .append_pair("includeDescription", &include_description.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::Package = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod query_package_version_metrics {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::PackageVersionMetricsQuery,
            pub(crate) feed_id: String,
            pub(crate) package_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::PackageVersionMetricsList, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/Feeds/{}/Packages/{}/versionmetricsbatch",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id,
                        &self.package_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::POST);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    req_builder = req_builder.header("content-type", "application/json");
                    let req_body = azure_core::to_json(&self.body).map_err(Error::Serialize)?;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::PackageVersionMetricsList =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_package_versions {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) feed_id: String,
            pub(crate) package_id: String,
            pub(crate) project: String,
            pub(crate) include_urls: Option<bool>,
            pub(crate) is_listed: Option<bool>,
            pub(crate) is_deleted: Option<bool>,
        }
        impl Builder {
            pub fn include_urls(mut self, include_urls: bool) -> Self {
                self.include_urls = Some(include_urls);
                self
            }
            pub fn is_listed(mut self, is_listed: bool) -> Self {
                self.is_listed = Some(is_listed);
                self
            }
            pub fn is_deleted(mut self, is_deleted: bool) -> Self {
                self.is_deleted = Some(is_deleted);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::PackageVersionList, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/Feeds/{}/Packages/{}/versions",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id,
                        &self.package_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    if let Some(include_urls) = &self.include_urls {
                        url.query_pairs_mut()
                            .append_pair("includeUrls", &include_urls.to_string());
                    }
                    if let Some(is_listed) = &self.is_listed {
                        url.query_pairs_mut()
                            .append_pair("isListed", &is_listed.to_string());
                    }
                    if let Some(is_deleted) = &self.is_deleted {
                        url.query_pairs_mut()
                            .append_pair("isDeleted", &is_deleted.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::PackageVersionList =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_package_version {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) feed_id: String,
            pub(crate) package_id: String,
            pub(crate) package_version_id: String,
            pub(crate) project: String,
            pub(crate) include_urls: Option<bool>,
            pub(crate) is_listed: Option<bool>,
            pub(crate) is_deleted: Option<bool>,
        }
        impl Builder {
            pub fn include_urls(mut self, include_urls: bool) -> Self {
                self.include_urls = Some(include_urls);
                self
            }
            pub fn is_listed(mut self, is_listed: bool) -> Self {
                self.is_listed = Some(is_listed);
                self
            }
            pub fn is_deleted(mut self, is_deleted: bool) -> Self {
                self.is_deleted = Some(is_deleted);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::PackageVersion, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/Feeds/{}/Packages/{}/versions/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id,
                        &self.package_id,
                        &self.package_version_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    if let Some(include_urls) = &self.include_urls {
                        url.query_pairs_mut()
                            .append_pair("includeUrls", &include_urls.to_string());
                    }
                    if let Some(is_listed) = &self.is_listed {
                        url.query_pairs_mut()
                            .append_pair("isListed", &is_listed.to_string());
                    }
                    if let Some(is_deleted) = &self.is_deleted {
                        url.query_pairs_mut()
                            .append_pair("isDeleted", &is_deleted.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::PackageVersion =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_package_version_provenance {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) feed_id: String,
            pub(crate) package_id: String,
            pub(crate) package_version_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::PackageVersionProvenance, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/Feeds/{}/Packages/{}/Versions/{}/provenance",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id,
                        &self.package_id,
                        &self.package_version_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::PackageVersionProvenance =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_badge {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) feed_id: String,
            pub(crate) package_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<String, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/public/packaging/Feeds/{}/Packages/{}/badge",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id,
                        &self.package_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: String = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
}
pub mod recycle_bin {
    use super::{models, API_VERSION};
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get_recycle_bin_packages(
            &self,
            organization: impl Into<String>,
            feed_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_recycle_bin_packages::Builder {
            get_recycle_bin_packages::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                feed_id: feed_id.into(),
                project: project.into(),
                protocol_type: None,
                package_name_query: None,
                include_urls: None,
                top: None,
                skip: None,
                include_all_versions: None,
            }
        }
        pub fn empty_recycle_bin(
            &self,
            organization: impl Into<String>,
            feed_id: impl Into<String>,
            project: impl Into<String>,
        ) -> empty_recycle_bin::Builder {
            empty_recycle_bin::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                feed_id: feed_id.into(),
                project: project.into(),
            }
        }
        pub fn get_recycle_bin_package(
            &self,
            organization: impl Into<String>,
            feed_id: impl Into<String>,
            package_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_recycle_bin_package::Builder {
            get_recycle_bin_package::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                feed_id: feed_id.into(),
                package_id: package_id.into(),
                project: project.into(),
                include_urls: None,
            }
        }
        pub fn get_recycle_bin_package_versions(
            &self,
            organization: impl Into<String>,
            feed_id: impl Into<String>,
            package_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_recycle_bin_package_versions::Builder {
            get_recycle_bin_package_versions::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                feed_id: feed_id.into(),
                package_id: package_id.into(),
                project: project.into(),
                include_urls: None,
            }
        }
        pub fn get_recycle_bin_package_version(
            &self,
            organization: impl Into<String>,
            feed_id: impl Into<String>,
            package_id: impl Into<String>,
            package_version_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_recycle_bin_package_version::Builder {
            get_recycle_bin_package_version::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                feed_id: feed_id.into(),
                package_id: package_id.into(),
                package_version_id: package_version_id.into(),
                project: project.into(),
                include_urls: None,
            }
        }
    }
    pub mod get_recycle_bin_packages {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) feed_id: String,
            pub(crate) project: String,
            pub(crate) protocol_type: Option<String>,
            pub(crate) package_name_query: Option<String>,
            pub(crate) include_urls: Option<bool>,
            pub(crate) top: Option<i32>,
            pub(crate) skip: Option<i32>,
            pub(crate) include_all_versions: Option<bool>,
        }
        impl Builder {
            pub fn protocol_type(mut self, protocol_type: impl Into<String>) -> Self {
                self.protocol_type = Some(protocol_type.into());
                self
            }
            pub fn package_name_query(mut self, package_name_query: impl Into<String>) -> Self {
                self.package_name_query = Some(package_name_query.into());
                self
            }
            pub fn include_urls(mut self, include_urls: bool) -> Self {
                self.include_urls = Some(include_urls);
                self
            }
            pub fn top(mut self, top: i32) -> Self {
                self.top = Some(top);
                self
            }
            pub fn skip(mut self, skip: i32) -> Self {
                self.skip = Some(skip);
                self
            }
            pub fn include_all_versions(mut self, include_all_versions: bool) -> Self {
                self.include_all_versions = Some(include_all_versions);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<models::PackageList, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/Feeds/{}/RecycleBin/Packages",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    if let Some(protocol_type) = &self.protocol_type {
                        url.query_pairs_mut()
                            .append_pair("protocolType", protocol_type);
                    }
                    if let Some(package_name_query) = &self.package_name_query {
                        url.query_pairs_mut()
                            .append_pair("packageNameQuery", package_name_query);
                    }
                    if let Some(include_urls) = &self.include_urls {
                        url.query_pairs_mut()
                            .append_pair("includeUrls", &include_urls.to_string());
                    }
                    if let Some(top) = &self.top {
                        url.query_pairs_mut().append_pair("$top", &top.to_string());
                    }
                    if let Some(skip) = &self.skip {
                        url.query_pairs_mut()
                            .append_pair("$skip", &skip.to_string());
                    }
                    if let Some(include_all_versions) = &self.include_all_versions {
                        url.query_pairs_mut()
                            .append_pair("includeAllVersions", &include_all_versions.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::PackageList = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod empty_recycle_bin {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) feed_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::OperationReference, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/Feeds/{}/RecycleBin/Packages",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::DELETE);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::OperationReference =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_recycle_bin_package {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) feed_id: String,
            pub(crate) package_id: String,
            pub(crate) project: String,
            pub(crate) include_urls: Option<bool>,
        }
        impl Builder {
            pub fn include_urls(mut self, include_urls: bool) -> Self {
                self.include_urls = Some(include_urls);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<models::Package, Error>>
            {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/Feeds/{}/RecycleBin/Packages/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id,
                        &self.package_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    if let Some(include_urls) = &self.include_urls {
                        url.query_pairs_mut()
                            .append_pair("includeUrls", &include_urls.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::Package = serde_json::from_slice(&rsp_body)
                                .map_err(|source| Error::Deserialize(source, rsp_body.clone()))?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_recycle_bin_package_versions {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) feed_id: String,
            pub(crate) package_id: String,
            pub(crate) project: String,
            pub(crate) include_urls: Option<bool>,
        }
        impl Builder {
            pub fn include_urls(mut self, include_urls: bool) -> Self {
                self.include_urls = Some(include_urls);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::RecycleBinPackageVersionList, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/Feeds/{}/RecycleBin/Packages/{}/Versions",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id,
                        &self.package_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    if let Some(include_urls) = &self.include_urls {
                        url.query_pairs_mut()
                            .append_pair("includeUrls", &include_urls.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::RecycleBinPackageVersionList =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod get_recycle_bin_package_version {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) feed_id: String,
            pub(crate) package_id: String,
            pub(crate) package_version_id: String,
            pub(crate) project: String,
            pub(crate) include_urls: Option<bool>,
        }
        impl Builder {
            pub fn include_urls(mut self, include_urls: bool) -> Self {
                self.include_urls = Some(include_urls);
                self
            }
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::RecycleBinPackageVersion, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/Feeds/{}/RecycleBin/Packages/{}/Versions/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id,
                        &self.package_id,
                        &self.package_version_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    if let Some(include_urls) = &self.include_urls {
                        url.query_pairs_mut()
                            .append_pair("includeUrls", &include_urls.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::RecycleBinPackageVersion =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
}
pub mod retention_policies {
    use super::{models, API_VERSION};
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get_retention_policy(
            &self,
            organization: impl Into<String>,
            feed_id: impl Into<String>,
            project: impl Into<String>,
        ) -> get_retention_policy::Builder {
            get_retention_policy::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                feed_id: feed_id.into(),
                project: project.into(),
            }
        }
        pub fn set_retention_policy(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::FeedRetentionPolicy>,
            feed_id: impl Into<String>,
            project: impl Into<String>,
        ) -> set_retention_policy::Builder {
            set_retention_policy::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                feed_id: feed_id.into(),
                project: project.into(),
            }
        }
        pub fn delete_retention_policy(
            &self,
            organization: impl Into<String>,
            feed_id: impl Into<String>,
            project: impl Into<String>,
        ) -> delete_retention_policy::Builder {
            delete_retention_policy::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                feed_id: feed_id.into(),
                project: project.into(),
            }
        }
    }
    pub mod get_retention_policy {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) feed_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::FeedRetentionPolicy, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/Feeds/{}/retentionpolicies",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::GET);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::FeedRetentionPolicy =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod set_retention_policy {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::FeedRetentionPolicy,
            pub(crate) feed_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::FeedRetentionPolicy, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/Feeds/{}/retentionpolicies",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::PUT);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    req_builder = req_builder.header("content-type", "application/json");
                    let req_body = azure_core::to_json(&self.body).map_err(Error::Serialize)?;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::FeedRetentionPolicy =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
    pub mod delete_retention_policy {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) feed_id: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<'static, std::result::Result<(), Error>> {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/packaging/Feeds/{}/retentionpolicies",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.feed_id
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::DELETE);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    let req_body = azure_core::EMPTY_BODY;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => Ok(()),
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
}
pub mod provenance {
    use super::{models, API_VERSION};
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn create_session(
            &self,
            organization: impl Into<String>,
            body: impl Into<models::SessionRequest>,
            protocol: impl Into<String>,
            project: impl Into<String>,
        ) -> create_session::Builder {
            create_session::Builder {
                client: self.0.clone(),
                organization: organization.into(),
                body: body.into(),
                protocol: protocol.into(),
                project: project.into(),
            }
        }
    }
    pub mod create_session {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse {
                status_code: http::StatusCode,
                body: bytes::Bytes,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrl(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequest(http::Error),
            #[error("Failed to serialize request body: {0}")]
            Serialize(serde_json::Error),
            #[error("Failed to get access token: {0}")]
            GetToken(azure_core::Error),
            #[error("Failed to execute request: {0}")]
            SendRequest(azure_core::Error),
            #[error("Failed to get response bytes: {0}")]
            ResponseBytes(azure_core::StreamError),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            Deserialize(serde_json::Error, bytes::Bytes),
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) organization: String,
            pub(crate) body: models::SessionRequest,
            pub(crate) protocol: String,
            pub(crate) project: String,
        }
        impl Builder {
            pub fn into_future(
                self,
            ) -> futures::future::BoxFuture<
                'static,
                std::result::Result<models::SessionResponse, Error>,
            > {
                Box::pin(async move {
                    let url_str = &format!(
                        "{}/{}/{}/_apis/provenance/session/{}",
                        self.client.endpoint(),
                        &self.organization,
                        &self.project,
                        &self.protocol
                    );
                    let mut url = url::Url::parse(url_str).map_err(Error::ParseUrl)?;
                    let mut req_builder = http::request::Builder::new();
                    req_builder = req_builder.method(http::Method::POST);
                    let credential = self.client.token_credential();
                    let token_response = credential
                        .get_token(&self.client.scopes().join(" "))
                        .await
                        .map_err(Error::GetToken)?;
                    req_builder = req_builder.header(
                        http::header::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    url.query_pairs_mut()
                        .append_pair("api-version", super::API_VERSION);
                    req_builder = req_builder.header("content-type", "application/json");
                    let req_body = azure_core::to_json(&self.body).map_err(Error::Serialize)?;
                    req_builder = req_builder.uri(url.as_str());
                    let req = req_builder.body(req_body).map_err(Error::BuildRequest)?;
                    let rsp = self.client.send(req).await.map_err(Error::SendRequest)?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        http::StatusCode::OK => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            let rsp_value: models::SessionResponse =
                                serde_json::from_slice(&rsp_body).map_err(|source| {
                                    Error::Deserialize(source, rsp_body.clone())
                                })?;
                            Ok(rsp_value)
                        }
                        status_code => {
                            let rsp_body = azure_core::collect_pinned_stream(rsp_stream)
                                .await
                                .map_err(Error::ResponseBytes)?;
                            Err(Error::UnexpectedResponse {
                                status_code,
                                body: rsp_body,
                            })
                        }
                    }
                })
            }
        }
    }
}
